"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_pnpm_family_0_1_6_react-dom_18_3_1_react_18_3_1__react_18_3_1-092e4c"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/family@0.1.6_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.43.5_bufferutil@4.1.0_t_6a2b9601286a0c7e5bca7efaba4efca1/node_modules/family/lib/index-Cs-onntv.js":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/family@0.1.6_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.43.5_bufferutil@4.1.0_t_6a2b9601286a0c7e5bca7efaba4efca1/node_modules/family/lib/index-Cs-onntv.js ***!
  \***********************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: function() { return /* binding */ index$1; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js\")[\"Buffer\"];\nfunction _mergeNamespaces(n, m) {\n\tm.forEach(function (e) {\n\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\treturn Object.freeze(n);\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar postRobot$1 = {exports: {}};\n\nvar postRobot = {exports: {}};\n\n(function (module, exports) {\n\t!function(root, factory) {\n\t    module.exports = factory() ;\n\t}(\"undefined\" != typeof self ? self : commonjsGlobal, (function() {\n\t    return function(modules) {\n\t        var installedModules = {};\n\t        function __nested_webpack_require_1042__(moduleId) {\n\t            if (installedModules[moduleId]) return installedModules[moduleId].exports;\n\t            var module = installedModules[moduleId] = {\n\t                i: moduleId,\n\t                l: false,\n\t                exports: {}\n\t            };\n\t            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1042__);\n\t            module.l = true;\n\t            return module.exports;\n\t        }\n\t        __nested_webpack_require_1042__.m = modules;\n\t        __nested_webpack_require_1042__.c = installedModules;\n\t        __nested_webpack_require_1042__.d = function(exports, name, getter) {\n\t            __nested_webpack_require_1042__.o(exports, name) || Object.defineProperty(exports, name, {\n\t                enumerable: true,\n\t                get: getter\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.r = function(exports) {\n\t            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n\t                value: \"Module\"\n\t            });\n\t            Object.defineProperty(exports, \"__esModule\", {\n\t                value: true\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.t = function(value, mode) {\n\t            1 & mode && (value = __nested_webpack_require_1042__(value));\n\t            if (8 & mode) return value;\n\t            if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n\t            var ns = Object.create(null);\n\t            __nested_webpack_require_1042__.r(ns);\n\t            Object.defineProperty(ns, \"default\", {\n\t                enumerable: true,\n\t                value: value\n\t            });\n\t            if (2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_1042__.d(ns, key, function(key) {\n\t                return value[key];\n\t            }.bind(null, key));\n\t            return ns;\n\t        };\n\t        __nested_webpack_require_1042__.n = function(module) {\n\t            var getter = module && module.__esModule ? function() {\n\t                return module.default;\n\t            } : function() {\n\t                return module;\n\t            };\n\t            __nested_webpack_require_1042__.d(getter, \"a\", getter);\n\t            return getter;\n\t        };\n\t        __nested_webpack_require_1042__.o = function(object, property) {\n\t            return {}.hasOwnProperty.call(object, property);\n\t        };\n\t        __nested_webpack_require_1042__.p = \"\";\n\t        return __nested_webpack_require_1042__(__nested_webpack_require_1042__.s = 0);\n\t    }([ function(module, __nested_webpack_exports__, __nested_webpack_require_3517__) {\n\t        __nested_webpack_require_3517__.r(__nested_webpack_exports__);\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"Promise\", (function() {\n\t            return promise_ZalgoPromise;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"TYPES\", (function() {\n\t            return src_types_TYPES_0;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"ProxyWindow\", (function() {\n\t            return window_ProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"setup\", (function() {\n\t            return setup;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"destroy\", (function() {\n\t            return destroy;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"serializeMessage\", (function() {\n\t            return setup_serializeMessage;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"deserializeMessage\", (function() {\n\t            return setup_deserializeMessage;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"createProxyWindow\", (function() {\n\t            return createProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"toProxyWindow\", (function() {\n\t            return setup_toProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"on\", (function() {\n\t            return on_on;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"once\", (function() {\n\t            return on_once;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"send\", (function() {\n\t            return send_send;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"markWindowKnown\", (function() {\n\t            return markWindowKnown;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"cleanUpWindow\", (function() {\n\t            return cleanUpWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"bridge\", (function() {}));\n\t        function isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\t        function getActualProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return win.location.protocol;\n\t        }\n\t        function getProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            if (win.mockDomain) {\n\t                var protocol = win.mockDomain.split(\"//\")[0];\n\t                if (protocol) return protocol;\n\t            }\n\t            return getActualProtocol(win);\n\t        }\n\t        function isAboutProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return \"about:\" === getProtocol(win);\n\t        }\n\t        function getParent(win) {\n\t            void 0 === win && (win = window);\n\t            if (win) try {\n\t                if (win.parent && win.parent !== win) return win.parent;\n\t            } catch (err) {}\n\t        }\n\t        function getOpener(win) {\n\t            void 0 === win && (win = window);\n\t            if (win && !getParent(win)) try {\n\t                return win.opener;\n\t            } catch (err) {}\n\t        }\n\t        function canReadFromWindow(win) {\n\t            try {\n\t                return !0;\n\t            } catch (err) {}\n\t            return false;\n\t        }\n\t        function getActualDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var location = win.location;\n\t            if (!location) throw new Error(\"Can not read window location\");\n\t            var protocol = getActualProtocol(win);\n\t            if (!protocol) throw new Error(\"Can not read window protocol\");\n\t            if (\"file:\" === protocol) return \"file://\";\n\t            if (\"about:\" === protocol) {\n\t                var parent = getParent(win);\n\t                return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n\t            }\n\t            var host = location.host;\n\t            if (!host) throw new Error(\"Can not read window host\");\n\t            return protocol + \"//\" + host;\n\t        }\n\t        function getDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var domain = getActualDomain(win);\n\t            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n\t        }\n\t        function isSameDomain(win) {\n\t            if (!function(win) {\n\t                try {\n\t                    if (win === window) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\t                    if (desc && !1 === desc.enumerable) return !1;\n\t                } catch (err) {}\n\t                try {\n\t                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (function(win) {\n\t                        void 0 === win && (win = window);\n\t                        return \"mock:\" === getProtocol(win);\n\t                    }(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (getActualDomain(win) === getActualDomain(window)) return !0;\n\t                } catch (err) {}\n\t                return false;\n\t            }(win)) return false;\n\t            try {\n\t                if (win === window) return !0;\n\t                if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                if (getDomain(window) === getDomain(win)) return !0;\n\t            } catch (err) {}\n\t            return false;\n\t        }\n\t        function assertSameDomain(win) {\n\t            if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n\t            return win;\n\t        }\n\t        function isAncestorParent(parent, child) {\n\t            if (!parent || !child) return false;\n\t            var childParent = getParent(child);\n\t            return childParent ? childParent === parent : -1 !== function(win) {\n\t                var result = [];\n\t                try {\n\t                    for (;win.parent !== win; ) {\n\t                        result.push(win.parent);\n\t                        win = win.parent;\n\t                    }\n\t                } catch (err) {}\n\t                return result;\n\t            }(child).indexOf(parent);\n\t        }\n\t        function getFrames(win) {\n\t            var result = [];\n\t            var frames;\n\t            try {\n\t                frames = win.frames;\n\t            } catch (err) {\n\t                frames = win;\n\t            }\n\t            var len;\n\t            try {\n\t                len = frames.length;\n\t            } catch (err) {}\n\t            if (0 === len) return result;\n\t            if (len) {\n\t                for (var i = 0; i < len; i++) {\n\t                    var frame = void 0;\n\t                    try {\n\t                        frame = frames[i];\n\t                    } catch (err) {\n\t                        continue;\n\t                    }\n\t                    result.push(frame);\n\t                }\n\t                return result;\n\t            }\n\t            for (var _i = 0; _i < 100; _i++) {\n\t                var _frame = void 0;\n\t                try {\n\t                    _frame = frames[_i];\n\t                } catch (err) {\n\t                    return result;\n\t                }\n\t                if (!_frame) return result;\n\t                result.push(_frame);\n\t            }\n\t            return result;\n\t        }\n\t        var iframeWindows = [];\n\t        var iframeFrames = [];\n\t        function isWindowClosed(win, allowMock) {\n\t            void 0 === allowMock && (allowMock = true);\n\t            try {\n\t                if (win === window) return !1;\n\t            } catch (err) {\n\t                return true;\n\t            }\n\t            try {\n\t                if (!win) return !0;\n\t            } catch (err) {\n\t                return true;\n\t            }\n\t            try {\n\t                if (win.closed) return !0;\n\t            } catch (err) {\n\t                return !err || err.message !== IE_WIN_ACCESS_ERROR;\n\t            }\n\t            if (allowMock && isSameDomain(win)) try {\n\t                if (win.mockclosed) return !0;\n\t            } catch (err) {}\n\t            try {\n\t                if (!win.parent || !win.top) return !0;\n\t            } catch (err) {}\n\t            var iframeIndex = function(collection, item) {\n\t                for (var i = 0; i < collection.length; i++) try {\n\t                    if (collection[i] === item) return i;\n\t                } catch (err) {}\n\t                return -1;\n\t            }(iframeWindows, win);\n\t            if (-1 !== iframeIndex) {\n\t                var frame = iframeFrames[iframeIndex];\n\t                if (frame && function(frame) {\n\t                    if (!frame.contentWindow) return true;\n\t                    if (!frame.parentNode) return true;\n\t                    var doc = frame.ownerDocument;\n\t                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n\t                        var parent = frame;\n\t                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;\n\t                        if (!parent.host || !doc.documentElement.contains(parent.host)) return true;\n\t                    }\n\t                    return false;\n\t                }(frame)) return true;\n\t            }\n\t            return false;\n\t        }\n\t        function getAncestor(win) {\n\t            void 0 === win && (win = window);\n\t            return getOpener(win = win || window) || getParent(win) || void 0;\n\t        }\n\t        function matchDomain(pattern, origin) {\n\t            if (\"string\" == typeof pattern) {\n\t                if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n\t                if (isRegex(origin)) return false;\n\t                if (Array.isArray(origin)) return false;\n\t            }\n\t            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {\n\t                return matchDomain(subpattern, origin);\n\t            })));\n\t        }\n\t        function isWindow(obj) {\n\t            try {\n\t                if (obj === window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (window.Window && obj instanceof window.Window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && obj.self === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && obj.parent === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && obj.top === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n\t            } catch (err) {\n\t                return true;\n\t            }\n\t            try {\n\t                if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n\t            } catch (err) {}\n\t            return false;\n\t        }\n\t        function getFrameForWindow(win) {\n\t            if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n\t            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n\t                var frame = _document$querySelect2[_i21];\n\t                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n\t            }\n\t        }\n\t        function closeWindow(win) {\n\t            if (function(win) {\n\t                void 0 === win && (win = window);\n\t                return Boolean(getParent(win));\n\t            }(win)) {\n\t                var frame = getFrameForWindow(win);\n\t                if (frame && frame.parentElement) {\n\t                    frame.parentElement.removeChild(frame);\n\t                    return;\n\t                }\n\t            }\n\t            try {\n\t                win.close();\n\t            } catch (err) {}\n\t        }\n\t        function utils_isPromise(item) {\n\t            try {\n\t                if (!item) return !1;\n\t                if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n\t                var _toString = {}.toString;\n\t                if (_toString) {\n\t                    var name = _toString.call(item);\n\t                    if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n\t                }\n\t                if (\"function\" == typeof item.then) return !0;\n\t            } catch (err) {\n\t                return false;\n\t            }\n\t            return false;\n\t        }\n\t        var dispatchedErrors = [];\n\t        var possiblyUnhandledPromiseHandlers = [];\n\t        var activeCount = 0;\n\t        var flushPromise;\n\t        function flushActive() {\n\t            if (!activeCount && flushPromise) {\n\t                var promise = flushPromise;\n\t                flushPromise = null;\n\t                promise.resolve();\n\t            }\n\t        }\n\t        function startActive() {\n\t            activeCount += 1;\n\t        }\n\t        function endActive() {\n\t            activeCount -= 1;\n\t            flushActive();\n\t        }\n\t        var promise_ZalgoPromise = function() {\n\t            function ZalgoPromise(handler) {\n\t                var _this = this;\n\t                this.resolved = void 0;\n\t                this.rejected = void 0;\n\t                this.errorHandled = void 0;\n\t                this.value = void 0;\n\t                this.error = void 0;\n\t                this.handlers = void 0;\n\t                this.dispatching = void 0;\n\t                this.stack = void 0;\n\t                this.resolved = false;\n\t                this.rejected = false;\n\t                this.errorHandled = false;\n\t                this.handlers = [];\n\t                if (handler) {\n\t                    var _result;\n\t                    var _error;\n\t                    var resolved = false;\n\t                    var rejected = false;\n\t                    var isAsync = false;\n\t                    startActive();\n\t                    try {\n\t                        handler((function(res) {\n\t                            if (isAsync) _this.resolve(res); else {\n\t                                resolved = !0;\n\t                                _result = res;\n\t                            }\n\t                        }), (function(err) {\n\t                            if (isAsync) _this.reject(err); else {\n\t                                rejected = !0;\n\t                                _error = err;\n\t                            }\n\t                        }));\n\t                    } catch (err) {\n\t                        endActive();\n\t                        this.reject(err);\n\t                        return;\n\t                    }\n\t                    endActive();\n\t                    isAsync = true;\n\t                    resolved ? this.resolve(_result) : rejected && this.reject(_error);\n\t                }\n\t            }\n\t            var _proto = ZalgoPromise.prototype;\n\t            _proto.resolve = function(result) {\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n\t                this.resolved = true;\n\t                this.value = result;\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.reject = function(error) {\n\t                var _this2 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n\t                if (!error) {\n\t                    var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n\t                    error = new Error(\"Expected reject to be called with Error, got \" + _err);\n\t                }\n\t                this.rejected = true;\n\t                this.error = error;\n\t                this.errorHandled || setTimeout((function() {\n\t                    _this2.errorHandled || function(err, promise) {\n\t                        if (-1 === dispatchedErrors.indexOf(err)) {\n\t                            dispatchedErrors.push(err);\n\t                            setTimeout((function() {\n\t                                throw err;\n\t                            }), 1);\n\t                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n\t                        }\n\t                    }(error, _this2);\n\t                }), 1);\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.asyncReject = function(error) {\n\t                this.errorHandled = true;\n\t                this.reject(error);\n\t                return this;\n\t            };\n\t            _proto.dispatch = function() {\n\t                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;\n\t                if (!this.dispatching && (resolved || rejected)) {\n\t                    this.dispatching = true;\n\t                    startActive();\n\t                    var chain = function(firstPromise, secondPromise) {\n\t                        return firstPromise.then((function(res) {\n\t                            secondPromise.resolve(res);\n\t                        }), (function(err) {\n\t                            secondPromise.reject(err);\n\t                        }));\n\t                    };\n\t                    for (var i = 0; i < handlers.length; i++) {\n\t                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;\n\t                        var _result2 = void 0;\n\t                        if (resolved) try {\n\t                            _result2 = onSuccess ? onSuccess(this.value) : this.value;\n\t                        } catch (err) {\n\t                            promise.reject(err);\n\t                            continue;\n\t                        } else if (rejected) {\n\t                            if (!onError) {\n\t                                promise.reject(this.error);\n\t                                continue;\n\t                            }\n\t                            try {\n\t                                _result2 = onError(this.error);\n\t                            } catch (err) {\n\t                                promise.reject(err);\n\t                                continue;\n\t                            }\n\t                        }\n\t                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n\t                            var promiseResult = _result2;\n\t                            promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);\n\t                            promiseResult.errorHandled = true;\n\t                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n\t                    }\n\t                    handlers.length = 0;\n\t                    this.dispatching = false;\n\t                    endActive();\n\t                }\n\t            };\n\t            _proto.then = function(onSuccess, onError) {\n\t                if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n\t                if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n\t                var promise = new ZalgoPromise;\n\t                this.handlers.push({\n\t                    promise: promise,\n\t                    onSuccess: onSuccess,\n\t                    onError: onError\n\t                });\n\t                this.errorHandled = true;\n\t                this.dispatch();\n\t                return promise;\n\t            };\n\t            _proto.catch = function(onError) {\n\t                return this.then(void 0, onError);\n\t            };\n\t            _proto.finally = function(onFinally) {\n\t                if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n\t                return this.then((function(result) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        return result;\n\t                    }));\n\t                }), (function(err) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        throw err;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.timeout = function(time, err) {\n\t                var _this3 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                var timeout = setTimeout((function() {\n\t                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n\t                }), time);\n\t                return this.then((function(result) {\n\t                    clearTimeout(timeout);\n\t                    return result;\n\t                }));\n\t            };\n\t            _proto.toPromise = function() {\n\t                if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n\t                return Promise.resolve(this);\n\t            };\n\t            _proto.lazy = function() {\n\t                this.errorHandled = true;\n\t                return this;\n\t            };\n\t            ZalgoPromise.resolve = function(value) {\n\t                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {\n\t                    return value.then(resolve, reject);\n\t                })) : (new ZalgoPromise).resolve(value);\n\t            };\n\t            ZalgoPromise.reject = function(error) {\n\t                return (new ZalgoPromise).reject(error);\n\t            };\n\t            ZalgoPromise.asyncReject = function(error) {\n\t                return (new ZalgoPromise).asyncReject(error);\n\t            };\n\t            ZalgoPromise.all = function(promises) {\n\t                var promise = new ZalgoPromise;\n\t                var count = promises.length;\n\t                var results = [].slice();\n\t                if (!count) {\n\t                    promise.resolve(results);\n\t                    return promise;\n\t                }\n\t                var chain = function(i, firstPromise, secondPromise) {\n\t                    return firstPromise.then((function(res) {\n\t                        results[i] = res;\n\t                        0 == (count -= 1) && promise.resolve(results);\n\t                    }), (function(err) {\n\t                        secondPromise.reject(err);\n\t                    }));\n\t                };\n\t                for (var i = 0; i < promises.length; i++) {\n\t                    var prom = promises[i];\n\t                    if (prom instanceof ZalgoPromise) {\n\t                        if (prom.resolved) {\n\t                            results[i] = prom.value;\n\t                            count -= 1;\n\t                            continue;\n\t                        }\n\t                    } else if (!utils_isPromise(prom)) {\n\t                        results[i] = prom;\n\t                        count -= 1;\n\t                        continue;\n\t                    }\n\t                    chain(i, ZalgoPromise.resolve(prom), promise);\n\t                }\n\t                0 === count && promise.resolve(results);\n\t                return promise;\n\t            };\n\t            ZalgoPromise.hash = function(promises) {\n\t                var result = {};\n\t                var awaitPromises = [];\n\t                var _loop = function(key) {\n\t                    if (promises.hasOwnProperty(key)) {\n\t                        var value = promises[key];\n\t                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {\n\t                            result[key] = res;\n\t                        }))) : result[key] = value;\n\t                    }\n\t                };\n\t                for (var key in promises) _loop(key);\n\t                return ZalgoPromise.all(awaitPromises).then((function() {\n\t                    return result;\n\t                }));\n\t            };\n\t            ZalgoPromise.map = function(items, method) {\n\t                return ZalgoPromise.all(items.map(method));\n\t            };\n\t            ZalgoPromise.onPossiblyUnhandledException = function(handler) {\n\t                return function(handler) {\n\t                    possiblyUnhandledPromiseHandlers.push(handler);\n\t                    return {\n\t                        cancel: function() {\n\t                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n\t                        }\n\t                    };\n\t                }(handler);\n\t            };\n\t            ZalgoPromise.try = function(method, context, args) {\n\t                if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n\t                var result;\n\t                startActive();\n\t                try {\n\t                    result = method.apply(context, args || []);\n\t                } catch (err) {\n\t                    endActive();\n\t                    return ZalgoPromise.reject(err);\n\t                }\n\t                endActive();\n\t                return ZalgoPromise.resolve(result);\n\t            };\n\t            ZalgoPromise.delay = function(_delay) {\n\t                return new ZalgoPromise((function(resolve) {\n\t                    setTimeout(resolve, _delay);\n\t                }));\n\t            };\n\t            ZalgoPromise.isPromise = function(value) {\n\t                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n\t            };\n\t            ZalgoPromise.flush = function() {\n\t                return function(Zalgo) {\n\t                    var promise = flushPromise = flushPromise || new Zalgo;\n\t                    flushActive();\n\t                    return promise;\n\t                }(ZalgoPromise);\n\t            };\n\t            return ZalgoPromise;\n\t        }();\n\t        function util_safeIndexOf(collection, item) {\n\t            for (var i = 0; i < collection.length; i++) try {\n\t                if (collection[i] === item) return i;\n\t            } catch (err) {}\n\t            return -1;\n\t        }\n\t        var weakmap_CrossDomainSafeWeakMap = function() {\n\t            function CrossDomainSafeWeakMap() {\n\t                this.name = void 0;\n\t                this.weakmap = void 0;\n\t                this.keys = void 0;\n\t                this.values = void 0;\n\t                this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n\t                if (function() {\n\t                    if (\"undefined\" == typeof WeakMap) return false;\n\t                    if (void 0 === Object.freeze) return false;\n\t                    try {\n\t                        var testWeakMap = new WeakMap;\n\t                        var testKey = {};\n\t                        Object.freeze(testKey);\n\t                        testWeakMap.set(testKey, \"__testvalue__\");\n\t                        return \"__testvalue__\" === testWeakMap.get(testKey);\n\t                    } catch (err) {\n\t                        return false;\n\t                    }\n\t                }()) try {\n\t                    this.weakmap = new WeakMap;\n\t                } catch (err) {}\n\t                this.keys = [];\n\t                this.values = [];\n\t            }\n\t            var _proto = CrossDomainSafeWeakMap.prototype;\n\t            _proto._cleanupClosedWindows = function() {\n\t                var weakmap = this.weakmap;\n\t                var keys = this.keys;\n\t                for (var i = 0; i < keys.length; i++) {\n\t                    var value = keys[i];\n\t                    if (isWindow(value) && isWindowClosed(value)) {\n\t                        if (weakmap) try {\n\t                            weakmap.delete(value);\n\t                        } catch (err) {}\n\t                        keys.splice(i, 1);\n\t                        this.values.splice(i, 1);\n\t                        i -= 1;\n\t                    }\n\t                }\n\t            };\n\t            _proto.isSafeToReadWrite = function(key) {\n\t                return !isWindow(key);\n\t            };\n\t            _proto.set = function(key, value) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.set(key, value);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var name = this.name;\n\t                    var entry = key[name];\n\t                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n\t                        value: [ key, value ],\n\t                        writable: !0\n\t                    });\n\t                    return;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var values = this.values;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 === index) {\n\t                    keys.push(key);\n\t                    values.push(value);\n\t                } else values[index] = value;\n\t            };\n\t            _proto.get = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return weakmap.get(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return entry && entry[0] === key ? entry[1] : void 0;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var index = util_safeIndexOf(this.keys, key);\n\t                if (-1 !== index) return this.values[index];\n\t            };\n\t            _proto.delete = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.delete(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 !== index) {\n\t                    keys.splice(index, 1);\n\t                    this.values.splice(index, 1);\n\t                }\n\t            };\n\t            _proto.has = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return !0;\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return !(!entry || entry[0] !== key);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                return -1 !== util_safeIndexOf(this.keys, key);\n\t            };\n\t            _proto.getOrSet = function(key, getter) {\n\t                if (this.has(key)) return this.get(key);\n\t                var value = getter();\n\t                this.set(key, value);\n\t                return value;\n\t            };\n\t            return CrossDomainSafeWeakMap;\n\t        }();\n\t        function getFunctionName(fn) {\n\t            return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n\t        }\n\t        function setFunctionName(fn, name) {\n\t            try {\n\t                delete fn.name;\n\t                fn.name = name;\n\t            } catch (err) {}\n\t            fn.__name__ = fn.displayName = name;\n\t            return fn;\n\t        }\n\t        function uniqueID() {\n\t            var chars = \"0123456789abcdef\";\n\t            return \"uid_\" + \"xxxxxxxxxx\".replace(/./g, (function() {\n\t                return chars.charAt(Math.floor(Math.random() * chars.length));\n\t            })) + \"_\" + function(str) {\n\t                if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {\n\t                    return String.fromCharCode(parseInt(p1, 16));\n\t                }))).replace(/[=]/g, \"\");\n\t                if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n\t                throw new Error(\"Can not find window.btoa or Buffer\");\n\t            }((new Date).toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n\t        }\n\t        var objectIDs;\n\t        function serializeArgs(args) {\n\t            try {\n\t                return JSON.stringify([].slice.call(args), (function(subkey, val) {\n\t                    return \"function\" == typeof val ? \"memoize[\" + function(obj) {\n\t                        objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;\n\t                        if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n\t                        var uid = objectIDs.get(obj);\n\t                        if (!uid) {\n\t                            uid = typeof obj + \":\" + uniqueID();\n\t                            objectIDs.set(obj, uid);\n\t                        }\n\t                        return uid;\n\t                    }(val) + \"]\" : \"undefined\" != typeof window && val instanceof window.Element || null !== val && \"object\" == typeof val && 1 === val.nodeType && \"object\" == typeof val.style && \"object\" == typeof val.ownerDocument ? {} : val;\n\t                }));\n\t            } catch (err) {\n\t                throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n\t            }\n\t        }\n\t        function getEmptyObject() {\n\t            return {};\n\t        }\n\t        var memoizeGlobalIndex = 0;\n\t        var memoizeGlobalIndexValidFrom = 0;\n\t        function memoize(method, options) {\n\t            void 0 === options && (options = {});\n\t            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;\n\t            var simpleCache;\n\t            var thisCache;\n\t            var memoizeIndex = memoizeGlobalIndex;\n\t            memoizeGlobalIndex += 1;\n\t            var memoizedFunction = function() {\n\t                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\t                if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n\t                    simpleCache = null;\n\t                    thisCache = null;\n\t                    memoizeIndex = memoizeGlobalIndex;\n\t                    memoizeGlobalIndex += 1;\n\t                }\n\t                var cache;\n\t                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n\t                var cacheKey;\n\t                try {\n\t                    cacheKey = serializeArgs(args);\n\t                } catch (_unused) {\n\t                    return method.apply(this, arguments);\n\t                }\n\t                var cacheResult = cache[cacheKey];\n\t                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n\t                    delete cache[cacheKey];\n\t                    cacheResult = null;\n\t                }\n\t                if (cacheResult) return cacheResult.value;\n\t                var time = Date.now();\n\t                var value = method.apply(this, arguments);\n\t                cache[cacheKey] = {\n\t                    time: time,\n\t                    value: value\n\t                };\n\t                return value;\n\t            };\n\t            memoizedFunction.reset = function() {\n\t                simpleCache = null;\n\t                thisCache = null;\n\t            };\n\t            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n\t        }\n\t        memoize.clear = function() {\n\t            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n\t        };\n\t        function memoizePromise(method) {\n\t            var cache = {};\n\t            function memoizedPromiseFunction() {\n\t                var _arguments = arguments, _this = this;\n\t                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\t                var key = serializeArgs(args);\n\t                if (cache.hasOwnProperty(key)) return cache[key];\n\t                cache[key] = promise_ZalgoPromise.try((function() {\n\t                    return method.apply(_this, _arguments);\n\t                })).finally((function() {\n\t                    delete cache[key];\n\t                }));\n\t                return cache[key];\n\t            }\n\t            memoizedPromiseFunction.reset = function() {\n\t                cache = {};\n\t            };\n\t            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n\t        }\n\t        function src_util_noop() {}\n\t        function stringifyError(err, level) {\n\t            void 0 === level && (level = 1);\n\t            if (level >= 3) return \"stringifyError stack overflow\";\n\t            try {\n\t                if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n\t                if (\"string\" == typeof err) return err;\n\t                if (err instanceof Error) {\n\t                    var stack = err && err.stack;\n\t                    var message = err && err.message;\n\t                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n\t                    if (stack) return stack;\n\t                    if (message) return message;\n\t                }\n\t                return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n\t            } catch (newErr) {\n\t                return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n\t            }\n\t        }\n\t        function stringify(item) {\n\t            return \"string\" == typeof item ? item : item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n\t        }\n\t        memoize((function(obj) {\n\t            if (Object.values) return Object.values(obj);\n\t            var result = [];\n\t            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n\t            return result;\n\t        }));\n\t        function util_isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        function util_getOrSet(obj, key, getter) {\n\t            if (obj.hasOwnProperty(key)) return obj[key];\n\t            var val = getter();\n\t            obj[key] = val;\n\t            return val;\n\t        }\n\t        function getBody() {\n\t            var body = document.body;\n\t            if (!body) throw new Error(\"Body element not found\");\n\t            return body;\n\t        }\n\t        function isDocumentReady() {\n\t            return Boolean(document.body) && \"complete\" === document.readyState;\n\t        }\n\t        function isDocumentInteractive() {\n\t            return Boolean(document.body) && \"interactive\" === document.readyState;\n\t        }\n\t        memoize((function() {\n\t            return new promise_ZalgoPromise((function(resolve) {\n\t                if (isDocumentReady() || isDocumentInteractive()) return resolve();\n\t                var interval = setInterval((function() {\n\t                    if (isDocumentReady() || isDocumentInteractive()) {\n\t                        clearInterval(interval);\n\t                        return resolve();\n\t                    }\n\t                }), 10);\n\t            }));\n\t        }));\n\t        var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n\t        var getCurrentScript = memoize((function() {\n\t            if (currentScript) return currentScript;\n\t            if (currentScript = function() {\n\t                try {\n\t                    var stack = function() {\n\t                        try {\n\t                            throw new Error(\"_\");\n\t                        } catch (err) {\n\t                            return err.stack || \"\";\n\t                        }\n\t                    }();\n\t                    var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n\t                    var scriptLocation = stackDetails && stackDetails[1];\n\t                    if (!scriptLocation) return;\n\t                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n\t                        var script = _Array$prototype$slic2[_i22];\n\t                        if (script.src && script.src === scriptLocation) return script;\n\t                    }\n\t                } catch (err) {}\n\t            }()) return currentScript;\n\t            throw new Error(\"Can not determine current script\");\n\t        }));\n\t        var currentUID = uniqueID();\n\t        memoize((function() {\n\t            var script;\n\t            try {\n\t                script = getCurrentScript();\n\t            } catch (err) {\n\t                return currentUID;\n\t            }\n\t            var uid = script.getAttribute(\"data-uid\");\n\t            if (uid && \"string\" == typeof uid) return uid;\n\t            if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n\t            if (script.src) {\n\t                var hashedString = function(str) {\n\t                    var hash = \"\";\n\t                    for (var i = 0; i < str.length; i++) {\n\t                        var total = str[i].charCodeAt(0) * i;\n\t                        str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));\n\t                        hash += String.fromCharCode(97 + Math.abs(total) % 26);\n\t                    }\n\t                    return hash;\n\t                }(JSON.stringify({\n\t                    src: script.src,\n\t                    dataset: script.dataset\n\t                }));\n\t                uid = \"uid_\" + hashedString.slice(hashedString.length - 30);\n\t            } else uid = uniqueID();\n\t            script.setAttribute(\"data-uid-auto\", uid);\n\t            return uid;\n\t        }));\n\t        function global_getGlobal(win) {\n\t            void 0 === win && (win = window);\n\t            var globalKey = \"__post_robot_10_0_46__\";\n\t            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n\t        }\n\t        var getObj = function() {\n\t            return {};\n\t        };\n\t        function globalStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return util_getOrSet(global_getGlobal(), key, (function() {\n\t                var store = defStore();\n\t                return {\n\t                    has: function(storeKey) {\n\t                        return store.hasOwnProperty(storeKey);\n\t                    },\n\t                    get: function(storeKey, defVal) {\n\t                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n\t                    },\n\t                    set: function(storeKey, val) {\n\t                        store[storeKey] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(storeKey) {\n\t                        delete store[storeKey];\n\t                    },\n\t                    getOrSet: function(storeKey, getter) {\n\t                        return util_getOrSet(store, storeKey, getter);\n\t                    },\n\t                    reset: function() {\n\t                        store = defStore();\n\t                    },\n\t                    keys: function() {\n\t                        return Object.keys(store);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        var WildCard = function() {};\n\t        function getWildcard() {\n\t            var global = global_getGlobal();\n\t            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;\n\t            return global.WINDOW_WILDCARD;\n\t        }\n\t        function windowStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return globalStore(\"windowStore\").getOrSet(key, (function() {\n\t                var winStore = new weakmap_CrossDomainSafeWeakMap;\n\t                var getStore = function(win) {\n\t                    return winStore.getOrSet(win, defStore);\n\t                };\n\t                return {\n\t                    has: function(win) {\n\t                        return getStore(win).hasOwnProperty(key);\n\t                    },\n\t                    get: function(win, defVal) {\n\t                        var store = getStore(win);\n\t                        return store.hasOwnProperty(key) ? store[key] : defVal;\n\t                    },\n\t                    set: function(win, val) {\n\t                        getStore(win)[key] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(win) {\n\t                        delete getStore(win)[key];\n\t                    },\n\t                    getOrSet: function(win, getter) {\n\t                        return util_getOrSet(getStore(win), key, getter);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        function getInstanceID() {\n\t            return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n\t        }\n\t        function resolveHelloPromise(win, _ref) {\n\t            var domain = _ref.domain;\n\t            var helloPromises = windowStore(\"helloPromises\");\n\t            var existingPromise = helloPromises.get(win);\n\t            existingPromise && existingPromise.resolve({\n\t                domain: domain\n\t            });\n\t            var newPromise = promise_ZalgoPromise.resolve({\n\t                domain: domain\n\t            });\n\t            helloPromises.set(win, newPromise);\n\t            return newPromise;\n\t        }\n\t        function sayHello(win, _ref4) {\n\t            return (0, _ref4.send)(win, \"postrobot_hello\", {\n\t                instanceID: getInstanceID()\n\t            }, {\n\t                domain: \"*\",\n\t                timeout: -1\n\t            }).then((function(_ref5) {\n\t                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;\n\t                resolveHelloPromise(win, {\n\t                    domain: origin\n\t                });\n\t                return {\n\t                    win: win,\n\t                    domain: origin,\n\t                    instanceID: instanceID\n\t                };\n\t            }));\n\t        }\n\t        function getWindowInstanceID(win, _ref6) {\n\t            var send = _ref6.send;\n\t            return windowStore(\"windowInstanceIDPromises\").getOrSet(win, (function() {\n\t                return sayHello(win, {\n\t                    send: send\n\t                }).then((function(_ref7) {\n\t                    return _ref7.instanceID;\n\t                }));\n\t            }));\n\t        }\n\t        function markWindowKnown(win) {\n\t            windowStore(\"knownWindows\").set(win, true);\n\t        }\n\t        function isSerializedType(item) {\n\t            return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n\t        }\n\t        function determineType(val) {\n\t            return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n\t        }\n\t        function serializeType(type, val) {\n\t            return {\n\t                __type__: type,\n\t                __val__: val\n\t            };\n\t        }\n\t        var _SERIALIZER;\n\t        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {\n\t            return serializeType(\"error\", {\n\t                message: _ref.message,\n\t                stack: _ref.stack,\n\t                code: _ref.code,\n\t                data: _ref.data\n\t            });\n\t        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {\n\t            return serializeType(\"regex\", val.source);\n\t        }, _SERIALIZER.date = function(val) {\n\t            return serializeType(\"date\", val.toJSON());\n\t        }, _SERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _SERIALIZER[void 0] = function(val) {\n\t            return serializeType(\"undefined\", val);\n\t        }, _SERIALIZER);\n\t        var defaultSerializers = {};\n\t        var _DESERIALIZER;\n\t        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {\n\t            throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.error = function(_ref2) {\n\t            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;\n\t            var error = new Error(_ref2.message);\n\t            error.code = code;\n\t            data && (error.data = data);\n\t            error.stack = stack + \"\\n\\n\" + error.stack;\n\t            return error;\n\t        }, _DESERIALIZER.promise = function() {\n\t            throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.regex = function(val) {\n\t            return new RegExp(val);\n\t        }, _DESERIALIZER.date = function(val) {\n\t            return new Date(val);\n\t        }, _DESERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER[void 0] = function() {}, _DESERIALIZER);\n\t        var defaultDeserializers = {};\n\t        new promise_ZalgoPromise((function(resolve) {\n\t            if (window.document && window.document.body) return resolve(window.document.body);\n\t            var interval = setInterval((function() {\n\t                if (window.document && window.document.body) {\n\t                    clearInterval(interval);\n\t                    return resolve(window.document.body);\n\t                }\n\t            }), 10);\n\t        }));\n\t        function cleanupProxyWindows() {\n\t            var idToProxyWindow = globalStore(\"idToProxyWindow\");\n\t            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n\t                var id = _idToProxyWindow$keys2[_i2];\n\t                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n\t            }\n\t        }\n\t        function getSerializedWindow(winPromise, _ref) {\n\t            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;\n\t            var windowNamePromise = winPromise.then((function(win) {\n\t                if (isSameDomain(win)) return assertSameDomain(win).name;\n\t            }));\n\t            var windowTypePromise = winPromise.then((function(window) {\n\t                if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n\t                return getOpener(window) ? \"popup\" : \"iframe\";\n\t            }));\n\t            windowNamePromise.catch(src_util_noop);\n\t            windowTypePromise.catch(src_util_noop);\n\t            var getName = function() {\n\t                return winPromise.then((function(win) {\n\t                    if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n\t                }));\n\t            };\n\t            return {\n\t                id: id,\n\t                getType: function() {\n\t                    return windowTypePromise;\n\t                },\n\t                getInstanceID: memoizePromise((function() {\n\t                    return winPromise.then((function(win) {\n\t                        return getWindowInstanceID(win, {\n\t                            send: send\n\t                        });\n\t                    }));\n\t                })),\n\t                close: function() {\n\t                    return winPromise.then(closeWindow);\n\t                },\n\t                getName: getName,\n\t                focus: function() {\n\t                    return winPromise.then((function(win) {\n\t                        win.focus();\n\t                    }));\n\t                },\n\t                isClosed: function() {\n\t                    return winPromise.then((function(win) {\n\t                        return isWindowClosed(win);\n\t                    }));\n\t                },\n\t                setLocation: function(href, opts) {\n\t                    void 0 === opts && (opts = {});\n\t                    return winPromise.then((function(win) {\n\t                        var domain = window.location.protocol + \"//\" + window.location.host;\n\t                        var _opts$method = opts.method, method = void 0 === _opts$method ? \"get\" : _opts$method, body = opts.body;\n\t                        if (0 === href.indexOf(\"/\")) href = \"\" + domain + href; else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n\t                        if (\"post\" === method) return getName().then((function(name) {\n\t                            if (!name) throw new Error(\"Can not post to window without target name\");\n\t                            !function(_ref3) {\n\t                                var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? \"post\" : _ref3$method;\n\t                                var form = document.createElement(\"form\");\n\t                                form.setAttribute(\"target\", target);\n\t                                form.setAttribute(\"method\", method);\n\t                                form.setAttribute(\"action\", url);\n\t                                form.style.display = \"none\";\n\t                                if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {\n\t                                    var _body$key;\n\t                                    var key = _Object$keys4[_i24];\n\t                                    var input = document.createElement(\"input\");\n\t                                    input.setAttribute(\"name\", key);\n\t                                    input.setAttribute(\"value\", null == (_body$key = body[key]) ? void 0 : _body$key.toString());\n\t                                    form.appendChild(input);\n\t                                }\n\t                                getBody().appendChild(form);\n\t                                form.submit();\n\t                                getBody().removeChild(form);\n\t                            }({\n\t                                url: href,\n\t                                target: name,\n\t                                method: method,\n\t                                body: body\n\t                            });\n\t                        }));\n\t                        if (\"get\" !== method) throw new Error(\"Unsupported method: \" + method);\n\t                        if (isSameDomain(win)) try {\n\t                            if (win.location && \"function\" == typeof win.location.replace) {\n\t                                win.location.replace(href);\n\t                                return;\n\t                            }\n\t                        } catch (err) {}\n\t                        win.location = href;\n\t                    }));\n\t                },\n\t                setName: function(name) {\n\t                    return winPromise.then((function(win) {\n\t                        var sameDomain = isSameDomain(win);\n\t                        var frame = getFrameForWindow(win);\n\t                        if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n\t                        assertSameDomain(win).name = name;\n\t                        frame && frame.setAttribute(\"name\", name);\n\t                        windowNamePromise = promise_ZalgoPromise.resolve(name);\n\t                    }));\n\t                }\n\t            };\n\t        }\n\t        var window_ProxyWindow = function() {\n\t            function ProxyWindow(_ref2) {\n\t                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;\n\t                this.id = void 0;\n\t                this.isProxyWindow = true;\n\t                this.serializedWindow = void 0;\n\t                this.actualWindow = void 0;\n\t                this.actualWindowPromise = void 0;\n\t                this.send = void 0;\n\t                this.name = void 0;\n\t                this.actualWindowPromise = new promise_ZalgoPromise;\n\t                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send\n\t                });\n\t                globalStore(\"idToProxyWindow\").set(this.getID(), this);\n\t                win && this.setWindow(win, {\n\t                    send: send\n\t                });\n\t            }\n\t            var _proto = ProxyWindow.prototype;\n\t            _proto.getID = function() {\n\t                return this.serializedWindow.id;\n\t            };\n\t            _proto.getType = function() {\n\t                return this.serializedWindow.getType();\n\t            };\n\t            _proto.isPopup = function() {\n\t                return this.getType().then((function(type) {\n\t                    return \"popup\" === type;\n\t                }));\n\t            };\n\t            _proto.setLocation = function(href, opts) {\n\t                var _this = this;\n\t                return this.serializedWindow.setLocation(href, opts).then((function() {\n\t                    return _this;\n\t                }));\n\t            };\n\t            _proto.getName = function() {\n\t                return this.serializedWindow.getName();\n\t            };\n\t            _proto.setName = function(name) {\n\t                var _this2 = this;\n\t                return this.serializedWindow.setName(name).then((function() {\n\t                    return _this2;\n\t                }));\n\t            };\n\t            _proto.close = function() {\n\t                var _this3 = this;\n\t                return this.serializedWindow.close().then((function() {\n\t                    return _this3;\n\t                }));\n\t            };\n\t            _proto.focus = function() {\n\t                var _this4 = this;\n\t                var isPopupPromise = this.isPopup();\n\t                var getNamePromise = this.getName();\n\t                var reopenPromise = promise_ZalgoPromise.hash({\n\t                    isPopup: isPopupPromise,\n\t                    name: getNamePromise\n\t                }).then((function(_ref3) {\n\t                    var name = _ref3.name;\n\t                    _ref3.isPopup && name && window.open(\"\", name, \"noopener\");\n\t                }));\n\t                var focusPromise = this.serializedWindow.focus();\n\t                return promise_ZalgoPromise.all([ reopenPromise, focusPromise ]).then((function() {\n\t                    return _this4;\n\t                }));\n\t            };\n\t            _proto.isClosed = function() {\n\t                return this.serializedWindow.isClosed();\n\t            };\n\t            _proto.getWindow = function() {\n\t                return this.actualWindow;\n\t            };\n\t            _proto.setWindow = function(win, _ref4) {\n\t                var send = _ref4.send;\n\t                this.actualWindow = win;\n\t                this.actualWindowPromise.resolve(this.actualWindow);\n\t                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send,\n\t                    id: this.getID()\n\t                });\n\t                windowStore(\"winToProxyWindow\").set(win, this);\n\t            };\n\t            _proto.awaitWindow = function() {\n\t                return this.actualWindowPromise;\n\t            };\n\t            _proto.matchWindow = function(win, _ref5) {\n\t                var _this5 = this;\n\t                var send = _ref5.send;\n\t                return promise_ZalgoPromise.try((function() {\n\t                    return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n\t                        proxyInstanceID: _this5.getInstanceID(),\n\t                        knownWindowInstanceID: getWindowInstanceID(win, {\n\t                            send: send\n\t                        })\n\t                    }).then((function(_ref6) {\n\t                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n\t                        match && _this5.setWindow(win, {\n\t                            send: send\n\t                        });\n\t                        return match;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.unwrap = function() {\n\t                return this.actualWindow || this;\n\t            };\n\t            _proto.getInstanceID = function() {\n\t                return this.serializedWindow.getInstanceID();\n\t            };\n\t            _proto.shouldClean = function() {\n\t                return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n\t            };\n\t            _proto.serialize = function() {\n\t                return this.serializedWindow;\n\t            };\n\t            ProxyWindow.unwrap = function(win) {\n\t                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n\t            };\n\t            ProxyWindow.serialize = function(win, _ref7) {\n\t                var send = _ref7.send;\n\t                cleanupProxyWindows();\n\t                return ProxyWindow.toProxyWindow(win, {\n\t                    send: send\n\t                }).serialize();\n\t            };\n\t            ProxyWindow.deserialize = function(serializedWindow, _ref8) {\n\t                var send = _ref8.send;\n\t                cleanupProxyWindows();\n\t                return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n\t                    serializedWindow: serializedWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            ProxyWindow.isProxyWindow = function(obj) {\n\t                return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n\t            };\n\t            ProxyWindow.toProxyWindow = function(win, _ref9) {\n\t                var send = _ref9.send;\n\t                cleanupProxyWindows();\n\t                if (ProxyWindow.isProxyWindow(win)) return win;\n\t                var actualWindow = win;\n\t                return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n\t                    win: actualWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            return ProxyWindow;\n\t        }();\n\t        function addMethod(id, val, name, source, domain) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n\t                val: val,\n\t                name: name,\n\t                domain: domain,\n\t                source: source\n\t            }); else {\n\t                proxyWindowMethods.del(id);\n\t                methodStore.getOrSet(source, (function() {\n\t                    return {};\n\t                }))[id] = {\n\t                    domain: domain,\n\t                    name: name,\n\t                    val: val,\n\t                    source: source\n\t                };\n\t            }\n\t        }\n\t        function lookupMethod(source, id) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            return methodStore.getOrSet(source, (function() {\n\t                return {};\n\t            }))[id] || proxyWindowMethods.get(id);\n\t        }\n\t        function function_serializeFunction(destination, domain, val, key, _ref3) {\n\t            on = (_ref = {\n\t                on: _ref3.on,\n\t                send: _ref3.send\n\t            }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", (function() {\n\t                return on(\"postrobot_method\", {\n\t                    domain: \"*\"\n\t                }, (function(_ref2) {\n\t                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;\n\t                    var id = data.id, name = data.name;\n\t                    var meth = lookupMethod(source, id);\n\t                    if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n\t                    var methodSource = meth.source, domain = meth.domain, val = meth.val;\n\t                    return promise_ZalgoPromise.try((function() {\n\t                        if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n\t                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n\t                            send: send\n\t                        }).then((function(match) {\n\t                            if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n\t                        }));\n\t                    })).then((function() {\n\t                        return val.apply({\n\t                            source: source,\n\t                            origin: origin\n\t                        }, data.args);\n\t                    }), (function(err) {\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            if (val.onError) return val.onError(err);\n\t                        })).then((function() {\n\t                            err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function(args) {\n\t                                void 0 === args && (args = []);\n\t                                return (item = args, [].slice.call(item)).map((function(arg) {\n\t                                    return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n\t                                })).join(\", \");\n\t                                var item;\n\t                            }(data.args) + \") failed\\n\\n\" + err.stack);\n\t                            throw err;\n\t                        }));\n\t                    })).then((function(result) {\n\t                        return {\n\t                            result: result,\n\t                            id: id,\n\t                            name: name\n\t                        };\n\t                    }));\n\t                }));\n\t            }));\n\t            var _ref, on, send;\n\t            var id = val.__id__ || uniqueID();\n\t            destination = window_ProxyWindow.unwrap(destination);\n\t            var name = val.__name__ || val.name || key;\n\t            \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n\t            if (window_ProxyWindow.isProxyWindow(destination)) {\n\t                addMethod(id, val, name, destination, domain);\n\t                destination.awaitWindow().then((function(win) {\n\t                    addMethod(id, val, name, win, domain);\n\t                }));\n\t            } else addMethod(id, val, name, destination, domain);\n\t            return serializeType(\"cross_domain_function\", {\n\t                id: id,\n\t                name: name\n\t            });\n\t        }\n\t        function serializeMessage(destination, domain, obj, _ref) {\n\t            var _serialize;\n\t            var on = _ref.on, send = _ref.send;\n\t            return function(obj, serializers) {\n\t                void 0 === serializers && (serializers = defaultSerializers);\n\t                var result = JSON.stringify(obj, (function(key) {\n\t                    var val = this[key];\n\t                    if (isSerializedType(this)) return val;\n\t                    var type = determineType(val);\n\t                    if (!type) return val;\n\t                    var serializer = serializers[type] || SERIALIZER[type];\n\t                    return serializer ? serializer(val, key) : val;\n\t                }));\n\t                return void 0 === result ? \"undefined\" : result;\n\t            }(obj, ((_serialize = {}).promise = function(val, key) {\n\t                return function(destination, domain, val, key, _ref) {\n\t                    return serializeType(\"cross_domain_zalgo_promise\", {\n\t                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {\n\t                            return val.then(resolve, reject);\n\t                        }), key, {\n\t                            on: _ref.on,\n\t                            send: _ref.send\n\t                        })\n\t                    });\n\t                }(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.function = function(val, key) {\n\t                return function_serializeFunction(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.object = function(val) {\n\t                return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n\t                    send: send\n\t                })) : val;\n\t            }, _serialize));\n\t        }\n\t        function deserializeMessage(source, origin, message, _ref2) {\n\t            var _deserialize;\n\t            var send = _ref2.send;\n\t            return function(str, deserializers) {\n\t                void 0 === deserializers && (deserializers = defaultDeserializers);\n\t                if (\"undefined\" !== str) return JSON.parse(str, (function(key, val) {\n\t                    if (isSerializedType(this)) return val;\n\t                    var type;\n\t                    var value;\n\t                    if (isSerializedType(val)) {\n\t                        type = val.__type__;\n\t                        value = val.__val__;\n\t                    } else {\n\t                        type = determineType(val);\n\t                        value = val;\n\t                    }\n\t                    if (!type) return value;\n\t                    var deserializer = deserializers[type] || DESERIALIZER[type];\n\t                    return deserializer ? deserializer(value, key) : value;\n\t                }));\n\t            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {\n\t                return function(source, origin, _ref2) {\n\t                    return new promise_ZalgoPromise(_ref2.then);\n\t                }(0, 0, serializedPromise);\n\t            }, _deserialize.cross_domain_function = function(serializedFunction) {\n\t                return function(source, origin, _ref4, _ref5) {\n\t                    var id = _ref4.id, name = _ref4.name;\n\t                    var send = _ref5.send;\n\t                    var getDeserializedFunction = function(opts) {\n\t                        void 0 === opts && (opts = {});\n\t                        function crossDomainFunctionWrapper() {\n\t                            var _arguments = arguments;\n\t                            return window_ProxyWindow.toProxyWindow(source, {\n\t                                send: send\n\t                            }).awaitWindow().then((function(win) {\n\t                                var meth = lookupMethod(win, id);\n\t                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n\t                                    source: window,\n\t                                    origin: getDomain()\n\t                                }, _arguments);\n\t                                var _args = [].slice.call(_arguments);\n\t                                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: true\n\t                                }) : send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: false\n\t                                }).then((function(res) {\n\t                                    return res.data.result;\n\t                                }));\n\t                            })).catch((function(err) {\n\t                                throw err;\n\t                            }));\n\t                        }\n\t                        crossDomainFunctionWrapper.__name__ = name;\n\t                        crossDomainFunctionWrapper.__origin__ = origin;\n\t                        crossDomainFunctionWrapper.__source__ = source;\n\t                        crossDomainFunctionWrapper.__id__ = id;\n\t                        crossDomainFunctionWrapper.origin = origin;\n\t                        return crossDomainFunctionWrapper;\n\t                    };\n\t                    var crossDomainFunctionWrapper = getDeserializedFunction();\n\t                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n\t                        fireAndForget: true\n\t                    });\n\t                    return crossDomainFunctionWrapper;\n\t                }(source, origin, serializedFunction, {\n\t                    send: send\n\t                });\n\t            }, _deserialize.cross_domain_window = function(serializedWindow) {\n\t                return window_ProxyWindow.deserialize(serializedWindow, {\n\t                    send: send\n\t                });\n\t            }, _deserialize));\n\t        }\n\t        var SEND_MESSAGE_STRATEGIES = {};\n\t        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {\n\t            0 === domain.indexOf(\"file:\") && (domain = \"*\");\n\t            win.postMessage(serializedMessage, domain);\n\t        };\n\t        function send_sendMessage(win, domain, message, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            return promise_ZalgoPromise.try((function() {\n\t                var domainBuffer = windowStore().getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                domainBuffer.buffer = domainBuffer.buffer || [];\n\t                domainBuffer.buffer.push(message);\n\t                domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {\n\t                    if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n\t                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_46__ = domainBuffer.buffer || [], \n\t                    _ref), {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                    var _ref;\n\t                    delete domainBuffer.buffer;\n\t                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n\t                    var errors = [];\n\t                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n\t                        var strategyName = strategies[_i2];\n\t                        try {\n\t                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n\t                        } catch (err) {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                    if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map((function(err, i) {\n\t                        return i + \". \" + stringifyError(err);\n\t                    })).join(\"\\n\\n\"));\n\t                }));\n\t                return domainBuffer.flush.then((function() {\n\t                    delete domainBuffer.flush;\n\t                }));\n\t            })).then(src_util_noop);\n\t        }\n\t        function getResponseListener(hash) {\n\t            return globalStore(\"responseListeners\").get(hash);\n\t        }\n\t        function deleteResponseListener(hash) {\n\t            globalStore(\"responseListeners\").del(hash);\n\t        }\n\t        function isResponseListenerErrored(hash) {\n\t            return globalStore(\"erroredResponseListeners\").has(hash);\n\t        }\n\t        function getRequestListener(_ref) {\n\t            var name = _ref.name, win = _ref.win, domain = _ref.domain;\n\t            var requestListeners = windowStore(\"requestListeners\");\n\t            \"*\" === win && (win = null);\n\t            \"*\" === domain && (domain = null);\n\t            if (!name) throw new Error(\"Name required to get request listener\");\n\t            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {\n\t                var winQualifier = _ref3[_i4];\n\t                if (winQualifier) {\n\t                    var nameListeners = requestListeners.get(winQualifier);\n\t                    if (nameListeners) {\n\t                        var domainListeners = nameListeners[name];\n\t                        if (domainListeners) {\n\t                            if (domain && \"string\" == typeof domain) {\n\t                                if (domainListeners[domain]) return domainListeners[domain];\n\t                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n\t                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;\n\t                                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n\t                                }\n\t                            }\n\t                            if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function handleRequest(source, origin, message, _ref) {\n\t            var on = _ref.on, send = _ref.send;\n\t            var options = getRequestListener({\n\t                name: message.name,\n\t                win: source,\n\t                domain: origin\n\t            });\n\t            var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n\t            function sendResponse(ack, data, error) {\n\t                return promise_ZalgoPromise.flush().then((function() {\n\t                    if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                        return send_sendMessage(source, origin, {\n\t                            id: uniqueID(),\n\t                            origin: getDomain(window),\n\t                            type: \"postrobot_message_response\",\n\t                            hash: message.hash,\n\t                            name: message.name,\n\t                            ack: ack,\n\t                            data: data,\n\t                            error: error\n\t                        }, {\n\t                            on: on,\n\t                            send: send\n\t                        });\n\t                    } catch (err) {\n\t                        throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }\n\t                }));\n\t            }\n\t            return promise_ZalgoPromise.all([ promise_ZalgoPromise.flush().then((function() {\n\t                if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                    return send_sendMessage(source, origin, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_ack\",\n\t                        hash: message.hash,\n\t                        name: message.name\n\t                    }, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                }\n\t            })), promise_ZalgoPromise.try((function() {\n\t                if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                return options.handler({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            })).then((function(data) {\n\t                return sendResponse(\"success\", data);\n\t            }), (function(error) {\n\t                return sendResponse(\"error\", null, error);\n\t            })) ]).then(src_util_noop).catch((function(err) {\n\t                if (options && options.handleError) return options.handleError(err);\n\t                throw err;\n\t            }));\n\t        }\n\t        function handleAck(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                try {\n\t                    if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n\t                    if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n\t                } catch (err) {\n\t                    options.promise.reject(err);\n\t                }\n\t                options.ack = true;\n\t            }\n\t        }\n\t        function handleResponse(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, \n\t                Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() + \")\" : pattern.toString()));\n\t                var pattern;\n\t                if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n\t                deleteResponseListener(message.hash);\n\t                \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            }\n\t        }\n\t        function receive_receiveMessage(event, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            var receivedMessages = globalStore(\"receivedMessages\");\n\t            try {\n\t                if (!window || window.closed || !event.source) return;\n\t            } catch (err) {\n\t                return;\n\t            }\n\t            var source = event.source, origin = event.origin;\n\t            var messages = function(message, source, origin, _ref) {\n\t                var on = _ref.on, send = _ref.send;\n\t                var parsedMessage;\n\t                try {\n\t                    parsedMessage = deserializeMessage(source, origin, message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    return;\n\t                }\n\t                if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n\t                    var parseMessages = parsedMessage.__post_robot_10_0_46__;\n\t                    if (Array.isArray(parseMessages)) return parseMessages;\n\t                }\n\t            }(event.data, source, origin, {\n\t                on: on,\n\t                send: send\n\t            });\n\t            if (messages) {\n\t                markWindowKnown(source);\n\t                for (var _i2 = 0; _i2 < messages.length; _i2++) {\n\t                    var message = messages[_i2];\n\t                    if (receivedMessages.has(message.id)) return;\n\t                    receivedMessages.set(message.id, true);\n\t                    if (isWindowClosed(source) && !message.fireAndForget) return;\n\t                    0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n\t                    try {\n\t                        \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n\t                            on: on,\n\t                            send: send\n\t                        }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n\t                    } catch (err) {\n\t                        setTimeout((function() {\n\t                            throw err;\n\t                        }), 0);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function on_on(name, options, handler) {\n\t            if (!name) throw new Error(\"Expected name\");\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            if (!handler) throw new Error(\"Expected handler\");\n\t            var requestListener = function addRequestListener(_ref4, listener) {\n\t                var name = _ref4.name, winCandidate = _ref4.win, domain = _ref4.domain;\n\t                var requestListeners = windowStore(\"requestListeners\");\n\t                if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n\t                if (winCandidate && \"*\" !== winCandidate && window_ProxyWindow.isProxyWindow(winCandidate)) {\n\t                    var requestListenerPromise = winCandidate.awaitWindow().then((function(actualWin) {\n\t                        return addRequestListener({\n\t                            name: name,\n\t                            win: actualWin,\n\t                            domain: domain\n\t                        }, listener);\n\t                    }));\n\t                    return {\n\t                        cancel: function() {\n\t                            requestListenerPromise.then((function(requestListener) {\n\t                                return requestListener.cancel();\n\t                            }), src_util_noop);\n\t                        }\n\t                    };\n\t                }\n\t                var win = winCandidate;\n\t                if (Array.isArray(win)) {\n\t                    var listenersCollection = [];\n\t                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        domain: domain,\n\t                        win: _win2[_i8]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                if (Array.isArray(domain)) {\n\t                    var _listenersCollection = [];\n\t                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        win: win,\n\t                        domain: _domain2[_i12]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                var existingListener = getRequestListener({\n\t                    name: name,\n\t                    win: win,\n\t                    domain: domain\n\t                });\n\t                win && \"*\" !== win || (win = getWildcard());\n\t                var strDomain = (domain = domain || \"*\").toString();\n\t                if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n\t                var winNameListeners = requestListeners.getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainListeners = util_getOrSet(winNameListeners, name, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainRegexListeners;\n\t                var winNameDomainRegexListener;\n\t                util_isRegex(domain) ? (winNameDomainRegexListeners = util_getOrSet(winNameDomainListeners, \"__domain_regex__\", (function() {\n\t                    return [];\n\t                }))).push(winNameDomainRegexListener = {\n\t                    regex: domain,\n\t                    listener: listener\n\t                }) : winNameDomainListeners[strDomain] = listener;\n\t                return {\n\t                    cancel: function() {\n\t                        delete winNameDomainListeners[strDomain];\n\t                        if (winNameDomainRegexListener) {\n\t                            winNameDomainRegexListeners.splice(winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1));\n\t                            winNameDomainRegexListeners.length || delete winNameDomainListeners.__domain_regex__;\n\t                        }\n\t                        Object.keys(winNameDomainListeners).length || delete winNameListeners[name];\n\t                        win && !Object.keys(winNameListeners).length && requestListeners.del(win);\n\t                    }\n\t                };\n\t            }({\n\t                name: name,\n\t                win: options.window,\n\t                domain: options.domain || \"*\"\n\t            }, {\n\t                handler: handler || options.handler,\n\t                handleError: options.errorHandler || function(err) {\n\t                    throw err;\n\t                }\n\t            });\n\t            return {\n\t                cancel: function() {\n\t                    requestListener.cancel();\n\t                }\n\t            };\n\t        }\n\t        function on_once(name, options, handler) {\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            var promise = new promise_ZalgoPromise;\n\t            var listener;\n\t            options.errorHandler = function(err) {\n\t                listener.cancel();\n\t                promise.reject(err);\n\t            };\n\t            listener = on_on(name, options, (function(event) {\n\t                listener.cancel();\n\t                promise.resolve(event);\n\t                if (handler) return handler(event);\n\t            }));\n\t            promise.cancel = listener.cancel;\n\t            return promise;\n\t        }\n\t        var send_send = function send(winOrProxyWin, name, data, options) {\n\t            var domainMatcher = (options = options || {}).domain || \"*\";\n\t            var responseTimeout = options.timeout || -1;\n\t            var childTimeout = options.timeout || 5e3;\n\t            var fireAndForget = options.fireAndForget || false;\n\t            return window_ProxyWindow.toProxyWindow(winOrProxyWin, {\n\t                send: send\n\t            }).awaitWindow().then((function(win) {\n\t                return promise_ZalgoPromise.try((function() {\n\t                    !function(name, win, domain) {\n\t                        if (!name) throw new Error(\"Expected name\");\n\t                        if (\"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n\t                        if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n\t                    }(name, win, domainMatcher);\n\t                    if (function(parent, child) {\n\t                        var actualParent = getAncestor(child);\n\t                        if (actualParent) return actualParent === parent;\n\t                        if (child === parent) return false;\n\t                        if (function(win) {\n\t                            void 0 === win && (win = window);\n\t                            try {\n\t                                if (win.top) return win.top;\n\t                            } catch (err) {}\n\t                            if (getParent(win) === win) return win;\n\t                            try {\n\t                                if (isAncestorParent(window, win) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            try {\n\t                                if (isAncestorParent(win, window) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            for (var _i7 = 0, _getAllChildFrames4 = function getAllChildFrames(win) {\n\t                                var result = [];\n\t                                for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n\t                                    var frame = _getFrames2[_i3];\n\t                                    result.push(frame);\n\t                                    for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n\t                                }\n\t                                return result;\n\t                            }(win); _i7 < _getAllChildFrames4.length; _i7++) {\n\t                                var frame = _getAllChildFrames4[_i7];\n\t                                try {\n\t                                    if (frame.top) return frame.top;\n\t                                } catch (err) {}\n\t                                if (getParent(frame) === frame) return frame;\n\t                            }\n\t                        }(child) === child) return false;\n\t                        for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return true;\n\t                        return false;\n\t                    }(window, win)) return function(win, timeout, name) {\n\t                        void 0 === timeout && (timeout = 5e3);\n\t                        void 0 === name && (name = \"Window\");\n\t                        var promise = function(win) {\n\t                            return windowStore(\"helloPromises\").getOrSet(win, (function() {\n\t                                return new promise_ZalgoPromise;\n\t                            }));\n\t                        }(win);\n\t                        -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n\t                        return promise;\n\t                    }(win, childTimeout);\n\t                })).then((function(_temp) {\n\t                    return function(win, targetDomain, actualDomain, _ref) {\n\t                        var send = _ref.send;\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {\n\t                                return actualDomain || sayHello(win, {\n\t                                    send: send\n\t                                }).then((function(_ref2) {\n\t                                    return _ref2.domain;\n\t                                }));\n\t                            })).then((function(normalizedDomain) {\n\t                                if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n\t                                return normalizedDomain;\n\t                            }));\n\t                        }));\n\t                    }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n\t                        send: send\n\t                    });\n\t                })).then((function(targetDomain) {\n\t                    var domain = targetDomain;\n\t                    var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n\t                    var promise = new promise_ZalgoPromise;\n\t                    var hash = name + \"_\" + uniqueID();\n\t                    if (!fireAndForget) {\n\t                        var responseListener = {\n\t                            name: name,\n\t                            win: win,\n\t                            domain: domain,\n\t                            promise: promise\n\t                        };\n\t                        !function(hash, listener) {\n\t                            globalStore(\"responseListeners\").set(hash, listener);\n\t                        }(hash, responseListener);\n\t                        var reqPromises = windowStore(\"requestPromises\").getOrSet(win, (function() {\n\t                            return [];\n\t                        }));\n\t                        reqPromises.push(promise);\n\t                        promise.catch((function() {\n\t                            !function(hash) {\n\t                                globalStore(\"erroredResponseListeners\").set(hash, true);\n\t                            }(hash);\n\t                            deleteResponseListener(hash);\n\t                        }));\n\t                        var totalAckTimeout = function(win) {\n\t                            return windowStore(\"knownWindows\").get(win, false);\n\t                        }(win) ? 1e4 : 2e3;\n\t                        var totalResTimeout = responseTimeout;\n\t                        var ackTimeout = totalAckTimeout;\n\t                        var resTimeout = totalResTimeout;\n\t                        var interval = function(method, time) {\n\t                            var timeout;\n\t                            !function loop() {\n\t                                timeout = setTimeout((function() {\n\t                                    !function() {\n\t                                        if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n\t                                        if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n\t                                        ackTimeout = Math.max(ackTimeout - 500, 0);\n\t                                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n\t                                        responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout && promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n\t                                    }();\n\t                                    loop();\n\t                                }), 500);\n\t                            }();\n\t                            return {\n\t                                cancel: function() {\n\t                                    clearTimeout(timeout);\n\t                                }\n\t                            };\n\t                        }();\n\t                        promise.finally((function() {\n\t                            interval.cancel();\n\t                            reqPromises.splice(reqPromises.indexOf(promise, 1));\n\t                        })).catch(src_util_noop);\n\t                    }\n\t                    return send_sendMessage(win, domain, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_request\",\n\t                        hash: hash,\n\t                        name: name,\n\t                        data: data,\n\t                        fireAndForget: fireAndForget\n\t                    }, {\n\t                        on: on_on,\n\t                        send: send\n\t                    }).then((function() {\n\t                        return fireAndForget ? promise.resolve() : promise;\n\t                    }), (function(err) {\n\t                        throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }));\n\t                }));\n\t            }));\n\t        };\n\t        function setup_serializeMessage(destination, domain, obj) {\n\t            return serializeMessage(destination, domain, obj, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup_deserializeMessage(source, origin, message) {\n\t            return deserializeMessage(source, origin, message, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function createProxyWindow(win) {\n\t            return new window_ProxyWindow({\n\t                send: send_send,\n\t                win: win\n\t            });\n\t        }\n\t        function setup_toProxyWindow(win) {\n\t            return window_ProxyWindow.toProxyWindow(win, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup() {\n\t            if (!global_getGlobal().initialized) {\n\t                global_getGlobal().initialized = true;\n\t                on = (_ref3 = {\n\t                    on: on_on,\n\t                    send: send_send\n\t                }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {\n\t                    return receive_receiveMessage(message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                };\n\t                !function(_ref5) {\n\t                    var on = _ref5.on, send = _ref5.send;\n\t                    globalStore().getOrSet(\"postMessageListener\", (function() {\n\t                        return function(obj, event, handler) {\n\t                            obj.addEventListener(\"message\", handler);\n\t                            return {\n\t                                cancel: function() {\n\t                                    obj.removeEventListener(\"message\", handler);\n\t                                }\n\t                            };\n\t                        }(window, 0, (function(event) {\n\t                            !function(event, _ref4) {\n\t                                var on = _ref4.on, send = _ref4.send;\n\t                                promise_ZalgoPromise.try((function() {\n\t                                    var source = event.source || event.sourceElement;\n\t                                    var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n\t                                    var data = event.data;\n\t                                    \"null\" === origin && (origin = \"file://\");\n\t                                    if (source) {\n\t                                        if (!origin) throw new Error(\"Post message did not have origin domain\");\n\t                                        receive_receiveMessage({\n\t                                            source: source,\n\t                                            origin: origin,\n\t                                            data: data\n\t                                        }, {\n\t                                            on: on,\n\t                                            send: send\n\t                                        });\n\t                                    }\n\t                                }));\n\t                            }(event, {\n\t                                on: on,\n\t                                send: send\n\t                            });\n\t                        }));\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t                !function(_ref8) {\n\t                    var on = _ref8.on, send = _ref8.send;\n\t                    globalStore(\"builtinListeners\").getOrSet(\"helloListener\", (function() {\n\t                        var listener = on(\"postrobot_hello\", {\n\t                            domain: \"*\"\n\t                        }, (function(_ref3) {\n\t                            resolveHelloPromise(_ref3.source, {\n\t                                domain: _ref3.origin\n\t                            });\n\t                            return {\n\t                                instanceID: getInstanceID()\n\t                            };\n\t                        }));\n\t                        var parent = getAncestor();\n\t                        parent && sayHello(parent, {\n\t                            send: send\n\t                        }).catch((function(err) {}));\n\t                        return listener;\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t            }\n\t            var _ref3, on, send, global;\n\t        }\n\t        function destroy() {\n\t            !function() {\n\t                var responseListeners = globalStore(\"responseListeners\");\n\t                for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n\t                    var hash = _responseListeners$ke2[_i2];\n\t                    var listener = responseListeners.get(hash);\n\t                    listener && (listener.cancelled = true);\n\t                    responseListeners.del(hash);\n\t                }\n\t            }();\n\t            (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n\t            var listener;\n\t            delete window.__post_robot_10_0_46__;\n\t        }\n\t        var src_types_TYPES_0 = true;\n\t        function cleanUpWindow(win) {\n\t            for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n\t        }\n\t        setup();\n\t    } ]);\n\t})); \n} (postRobot));\n\nvar postRobotExports$1 = postRobot.exports;\n\n/* @flow */\n\n(function (module) {\n\t// $FlowFixMe\n\tmodule.exports = postRobotExports$1; // eslint-disable-line import/no-commonjs\n\n\t// $FlowFixMe\n\tmodule.exports.default = module.exports; // eslint-disable-line import/no-commonjs \n} (postRobot$1));\n\nvar postRobotExports = postRobot$1.exports;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postRobotExports);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n\t__proto__: null,\n\tdefault: index\n}, [postRobotExports]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9mYW1pbHlAMC4xLjZfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV92aWVtQDIuNDMuNV9idWZmZXJ1dGlsQDQuMS4wX3RfNmEyYjk2MDEyODZhMGM3ZTViY2E3ZWZhYmE0ZWZjYTEvbm9kZV9tb2R1bGVzL2ZhbWlseS9saWIvaW5kZXgtQ3Mtb25udHYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGtCQUFrQiwrQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLCtCQUFtQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixTQUFTLCtCQUFtQjtBQUM1QixTQUFTLCtCQUFtQjtBQUM1QixhQUFhLCtCQUFtQjtBQUNoQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUIsa0NBQWtDLCtCQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsOEVBQThFLCtCQUFtQjtBQUNqRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBLFNBQVMsK0JBQW1C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O0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YscUNBQXFDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLG9DQUFvQztBQUN4STtBQUNBO0FBQ0EsT0FBTztBQUNQLEVBQUU7QUFDRixFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUV1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFtaWx5QDAuMS42X3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfdmllbUAyLjQzLjVfYnVmZmVydXRpbEA0LjEuMF90XzZhMmI5NjAxMjg2YTBjN2U1YmNhN2VmYWJhNGVmY2ExL25vZGVfbW9kdWxlcy9mYW1pbHkvbGliL2luZGV4LUNzLW9ubnR2LmpzPzkxYTciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XG5cdG0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHRcdGUgJiYgdHlwZW9mIGUgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHRcdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIShrIGluIG4pKSB7XG5cdFx0XHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHBvc3RSb2JvdCQxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHBvc3RSb2JvdCA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCFmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA7XG5cdH0oXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiBjb21tb25qc0dsb2JhbCwgKGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKG1vZHVsZXMpIHtcblx0ICAgICAgICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0ICAgICAgICAgICAgaWYgKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblx0ICAgICAgICAgICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHQgICAgICAgICAgICAgICAgaTogbW9kdWxlSWQsXG5cdCAgICAgICAgICAgICAgICBsOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHQgICAgICAgICAgICBtb2R1bGUubCA9IHRydWU7XG5cdCAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0ICAgICAgICB9XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuXHQgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcblx0ICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgICAgICAgICBnZXQ6IGdldHRlclxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcblx0ICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogXCJNb2R1bGVcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG5cdCAgICAgICAgICAgIDEgJiBtb2RlICYmICh2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpKTtcblx0ICAgICAgICAgICAgaWYgKDggJiBtb2RlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIGlmICg0ICYgbW9kZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgXCJkZWZhdWx0XCIsIHtcblx0ICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGlmICgyICYgbW9kZSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiB2YWx1ZSkgZm9yICh2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgfS5iaW5kKG51bGwsIGtleSkpO1xuXHQgICAgICAgICAgICByZXR1cm4gbnM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0ICAgICAgICAgICAgdmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5kZWZhdWx0O1xuXHQgICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCBcImFcIiwgZ2V0dGVyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldHRlcjtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHQgICAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuXHQgICAgfShbIGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQcm9taXNlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUWVBFU1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzcmNfdHlwZXNfVFlQRVNfMDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUHJveHlXaW5kb3dcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXR1cFwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVzdHJveVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZXN0cm95O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXJpYWxpemVNZXNzYWdlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwX3NlcmlhbGl6ZU1lc3NhZ2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlc2VyaWFsaXplTWVzc2FnZVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNyZWF0ZVByb3h5V2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5V2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b1Byb3h5V2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwX3RvUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9uXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9uX29uO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvbmNlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9uX29uY2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlbmRcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtYXJrV2luZG93S25vd25cIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbWFya1dpbmRvd0tub3duO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjbGVhblVwV2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNsZWFuVXBXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJyaWRnZVwiLCAoZnVuY3Rpb24oKSB7fSkpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGlzUmVnZXgoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIElFX1dJTl9BQ0NFU1NfRVJST1IgPSBcIkNhbGwgd2FzIHJlamVjdGVkIGJ5IGNhbGxlZS5cXHJcXG5cIjtcblx0ICAgICAgICBmdW5jdGlvbiBnZXRBY3R1YWxQcm90b2NvbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW4ubG9jYXRpb24ucHJvdG9jb2w7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFByb3RvY29sKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgaWYgKHdpbi5tb2NrRG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSB3aW4ubW9ja0RvbWFpbi5zcGxpdChcIi8vXCIpWzBdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHByb3RvY29sKSByZXR1cm4gcHJvdG9jb2w7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGdldEFjdHVhbFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzQWJvdXRQcm90b2NvbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHJldHVybiBcImFib3V0OlwiID09PSBnZXRQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRQYXJlbnQod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICBpZiAod2luKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbi5wYXJlbnQgJiYgd2luLnBhcmVudCAhPT0gd2luKSByZXR1cm4gd2luLnBhcmVudDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRPcGVuZXIod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICBpZiAod2luICYmICFnZXRQYXJlbnQod2luKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW4ub3BlbmVyO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGNhblJlYWRGcm9tV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0QWN0dWFsRG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gd2luLmxvY2F0aW9uO1xuXHQgICAgICAgICAgICBpZiAoIWxvY2F0aW9uKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IGxvY2F0aW9uXCIpO1xuXHQgICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBnZXRBY3R1YWxQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgICAgICBpZiAoIXByb3RvY29sKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IHByb3RvY29sXCIpO1xuXHQgICAgICAgICAgICBpZiAoXCJmaWxlOlwiID09PSBwcm90b2NvbCkgcmV0dXJuIFwiZmlsZTovL1wiO1xuXHQgICAgICAgICAgICBpZiAoXCJhYm91dDpcIiA9PT0gcHJvdG9jb2wpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQod2luKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgJiYgY2FuUmVhZEZyb21XaW5kb3coKSA/IGdldEFjdHVhbERvbWFpbihwYXJlbnQpIDogXCJhYm91dDovL1wiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBob3N0ID0gbG9jYXRpb24uaG9zdDtcblx0ICAgICAgICAgICAgaWYgKCFob3N0KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IGhvc3RcIik7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3Q7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldERvbWFpbih3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXRBY3R1YWxEb21haW4od2luKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGRvbWFpbiAmJiB3aW4ubW9ja0RvbWFpbiAmJiAwID09PSB3aW4ubW9ja0RvbWFpbi5pbmRleE9mKFwibW9jazpcIikgPyB3aW4ubW9ja0RvbWFpbiA6IGRvbWFpbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNTYW1lRG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAod2luID09PSB3aW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbiwgXCJsb2NhdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiAhMSA9PT0gZGVzYy5lbnVtZXJhYmxlKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc0Fib3V0UHJvdG9jb2wod2luKSAmJiBjYW5SZWFkRnJvbVdpbmRvdygpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1vY2s6XCIgPT09IGdldFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGdldEFjdHVhbERvbWFpbih3aW4pID09PSBnZXRBY3R1YWxEb21haW4od2luZG93KSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9KHdpbikpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIGlmIChnZXREb21haW4od2luZG93KSA9PT0gZ2V0RG9tYWluKHdpbikpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGFzc2VydFNhbWVEb21haW4od2luKSB7XG5cdCAgICAgICAgICAgIGlmICghaXNTYW1lRG9tYWluKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHdpbmRvdyB0byBiZSBzYW1lIGRvbWFpblwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNBbmNlc3RvclBhcmVudChwYXJlbnQsIGNoaWxkKSB7XG5cdCAgICAgICAgICAgIGlmICghcGFyZW50IHx8ICFjaGlsZCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRQYXJlbnQgPSBnZXRQYXJlbnQoY2hpbGQpO1xuXHQgICAgICAgICAgICByZXR1cm4gY2hpbGRQYXJlbnQgPyBjaGlsZFBhcmVudCA9PT0gcGFyZW50IDogLTEgIT09IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKDt3aW4ucGFyZW50ICE9PSB3aW47ICkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3aW4ucGFyZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luID0gd2luLnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9KGNoaWxkKS5pbmRleE9mKHBhcmVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYW1lcyh3aW4pIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgZnJhbWVzO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZnJhbWVzID0gd2luLmZyYW1lcztcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBmcmFtZXMgPSB3aW47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGxlbjtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGxlbiA9IGZyYW1lcy5sZW5ndGg7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgaWYgKDAgPT09IGxlbikgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgaWYgKGxlbikge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGZyYW1lc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDEwMDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gZnJhbWVzW19pXTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoIV9mcmFtZSkgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9mcmFtZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGlmcmFtZVdpbmRvd3MgPSBbXTtcblx0ICAgICAgICB2YXIgaWZyYW1lRnJhbWVzID0gW107XG5cdCAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3dDbG9zZWQod2luLCBhbGxvd01vY2spIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBhbGxvd01vY2sgJiYgKGFsbG93TW9jayA9IHRydWUpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghd2luKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4uY2xvc2VkKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICFlcnIgfHwgZXJyLm1lc3NhZ2UgIT09IElFX1dJTl9BQ0NFU1NfRVJST1I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGFsbG93TW9jayAmJiBpc1NhbWVEb21haW4od2luKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4ubW9ja2Nsb3NlZCkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXdpbi5wYXJlbnQgfHwgIXdpbi50b3ApIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB2YXIgaWZyYW1lSW5kZXggPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25baV0gPT09IGl0ZW0pIHJldHVybiBpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICB9KGlmcmFtZVdpbmRvd3MsIHdpbik7XG5cdCAgICAgICAgICAgIGlmICgtMSAhPT0gaWZyYW1lSW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGlmcmFtZUZyYW1lc1tpZnJhbWVJbmRleF07XG5cdCAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnVuY3Rpb24oZnJhbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLmNvbnRlbnRXaW5kb3cpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZnJhbWUucGFyZW50Tm9kZSkgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IGZyYW1lLm93bmVyRG9jdW1lbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRvYyAmJiBkb2MuZG9jdW1lbnRFbGVtZW50ICYmICFkb2MuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGZyYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZnJhbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO3BhcmVudC5wYXJlbnROb2RlICYmIHBhcmVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQ7ICkgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Lmhvc3QgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMocGFyZW50Lmhvc3QpKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfShmcmFtZSkpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0QW5jZXN0b3Iod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2V0T3BlbmVyKHdpbiA9IHdpbiB8fCB3aW5kb3cpIHx8IGdldFBhcmVudCh3aW4pIHx8IHZvaWQgMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbWF0Y2hEb21haW4ocGF0dGVybiwgb3JpZ2luKSB7XG5cdCAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBwYXR0ZXJuKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2Ygb3JpZ2luKSByZXR1cm4gXCIqXCIgPT09IHBhdHRlcm4gfHwgb3JpZ2luID09PSBwYXR0ZXJuO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzUmVnZXgob3JpZ2luKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBpc1JlZ2V4KHBhdHRlcm4pID8gaXNSZWdleChvcmlnaW4pID8gcGF0dGVybi50b1N0cmluZygpID09PSBvcmlnaW4udG9TdHJpbmcoKSA6ICFBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgQm9vbGVhbihvcmlnaW4ubWF0Y2gocGF0dGVybikpIDogISFBcnJheS5pc0FycmF5KHBhdHRlcm4pICYmIChBcnJheS5pc0FycmF5KG9yaWdpbikgPyBKU09OLnN0cmluZ2lmeShwYXR0ZXJuKSA9PT0gSlNPTi5zdHJpbmdpZnkob3JpZ2luKSA6ICFpc1JlZ2V4KG9yaWdpbikgJiYgcGF0dGVybi5zb21lKChmdW5jdGlvbihzdWJwYXR0ZXJuKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hEb21haW4oc3VicGF0dGVybiwgb3JpZ2luKTtcblx0ICAgICAgICAgICAgfSkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqID09PSB3aW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwiW29iamVjdCBXaW5kb3ddXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwob2JqKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luZG93LldpbmRvdyAmJiBvYmogaW5zdGFuY2VvZiB3aW5kb3cuV2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnNlbGYgPT09IG9iaikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5wYXJlbnQgPT09IG9iaikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai50b3AgPT09IG9iaikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIFwiX191bmxpa2VseV92YWx1ZV9fXCIgPT09IG9iai5fX2Nyb3NzX2RvbWFpbl91dGlsc193aW5kb3dfY2hlY2tfXykgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJwb3N0TWVzc2FnZVwiIGluIG9iaiAmJiBcInNlbGZcIiBpbiBvYmogJiYgXCJsb2NhdGlvblwiIGluIG9iaikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnJhbWVGb3JXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIGlmIChpc1NhbWVEb21haW4od2luKSkgcmV0dXJuIGFzc2VydFNhbWVEb21haW4od2luKS5mcmFtZUVsZW1lbnQ7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pMjEgPSAwLCBfZG9jdW1lbnQkcXVlcnlTZWxlY3QyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlmcmFtZVwiKTsgX2kyMSA8IF9kb2N1bWVudCRxdWVyeVNlbGVjdDIubGVuZ3RoOyBfaTIxKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9kb2N1bWVudCRxdWVyeVNlbGVjdDJbX2kyMV07XG5cdCAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnJhbWUuY29udGVudFdpbmRvdyAmJiBmcmFtZS5jb250ZW50V2luZG93ID09PSB3aW4pIHJldHVybiBmcmFtZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBjbG9zZVdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihnZXRQYXJlbnQod2luKSk7XG5cdCAgICAgICAgICAgIH0od2luKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gZ2V0RnJhbWVGb3JXaW5kb3cod2luKTtcblx0ICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmcmFtZS5wYXJlbnRFbGVtZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZnJhbWUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChmcmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB3aW4uY2xvc2UoKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB1dGlsc19pc1Byb21pc2UoaXRlbSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUHJvbWlzZSAmJiBpdGVtIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvdy5XaW5kb3cgJiYgaXRlbSBpbnN0YW5jZW9mIHdpbmRvdy5XaW5kb3cpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW5kb3cuY29uc3RydWN0b3IgJiYgaXRlbSBpbnN0YW5jZW9mIHdpbmRvdy5jb25zdHJ1Y3RvcikgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgdmFyIF90b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgaWYgKF90b1N0cmluZykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3RvU3RyaW5nLmNhbGwoaXRlbSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFwiW29iamVjdCBXaW5kb3ddXCIgPT09IG5hbWUgfHwgXCJbb2JqZWN0IGdsb2JhbF1cIiA9PT0gbmFtZSB8fCBcIltvYmplY3QgRE9NV2luZG93XVwiID09PSBuYW1lKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtLnRoZW4pIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGlzcGF0Y2hlZEVycm9ycyA9IFtdO1xuXHQgICAgICAgIHZhciBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycyA9IFtdO1xuXHQgICAgICAgIHZhciBhY3RpdmVDb3VudCA9IDA7XG5cdCAgICAgICAgdmFyIGZsdXNoUHJvbWlzZTtcblx0ICAgICAgICBmdW5jdGlvbiBmbHVzaEFjdGl2ZSgpIHtcblx0ICAgICAgICAgICAgaWYgKCFhY3RpdmVDb3VudCAmJiBmbHVzaFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZmx1c2hQcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgZmx1c2hQcm9taXNlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWN0aXZlKCkge1xuXHQgICAgICAgICAgICBhY3RpdmVDb3VudCArPSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBlbmRBY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIGFjdGl2ZUNvdW50IC09IDE7XG5cdCAgICAgICAgICAgIGZsdXNoQWN0aXZlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwcm9taXNlX1phbGdvUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBaYWxnb1Byb21pc2UoaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG5cdCAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIF90aGlzLnJlc29sdmUocmVzKTsgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0ID0gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIF90aGlzLnJlamVjdChlcnIpOyBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvciA9IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA/IHRoaXMucmVzb2x2ZShfcmVzdWx0KSA6IHJlamVjdGVkICYmIHRoaXMucmVqZWN0KF9lcnJvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9wcm90byA9IFphbGdvUHJvbWlzZS5wcm90b3R5cGU7XG5cdCAgICAgICAgICAgIF9wcm90by5yZXNvbHZlID0gZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh1dGlsc19pc1Byb21pc2UocmVzdWx0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBhbm90aGVyIHByb21pc2VcIik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnJlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkIHx8IHRoaXMucmVqZWN0ZWQpIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICAgICAgaWYgKHV0aWxzX2lzUHJvbWlzZShlcnJvcikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVqZWN0IHByb21pc2Ugd2l0aCBhbm90aGVyIHByb21pc2VcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9lcnIgPSBlcnJvciAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGVycm9yLnRvU3RyaW5nID8gZXJyb3IudG9TdHJpbmcoKSA6IHt9LnRvU3RyaW5nLmNhbGwoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiRXhwZWN0ZWQgcmVqZWN0IHRvIGJlIGNhbGxlZCB3aXRoIEVycm9yLCBnb3QgXCIgKyBfZXJyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgfHwgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmVycm9ySGFuZGxlZCB8fCBmdW5jdGlvbihlcnIsIHByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBkaXNwYXRjaGVkRXJyb3JzLmluZGV4T2YoZXJyKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlZEVycm9ycy5wdXNoKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLmxlbmd0aDsgaisrKSBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVyc1tqXShlcnIsIHByb21pc2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfShlcnJvciwgX3RoaXMyKTtcblx0ICAgICAgICAgICAgICAgIH0pLCAxKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uYXN5bmNSZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5kaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gdGhpcy5yZXNvbHZlZCwgcmVqZWN0ZWQgPSB0aGlzLnJlamVjdGVkLCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGF0Y2hpbmcgJiYgKHJlc29sdmVkIHx8IHJlamVjdGVkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoYWluID0gZnVuY3Rpb24oZmlyc3RQcm9taXNlLCBzZWNvbmRQcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdFByb21pc2UudGhlbigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlc29sdmUocmVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9oYW5kbGVycyRpID0gaGFuZGxlcnNbaV0sIG9uU3VjY2VzcyA9IF9oYW5kbGVycyRpLm9uU3VjY2Vzcywgb25FcnJvciA9IF9oYW5kbGVycyRpLm9uRXJyb3IsIHByb21pc2UgPSBfaGFuZGxlcnMkaS5wcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdDIgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQyID0gb25TdWNjZXNzID8gb25TdWNjZXNzKHRoaXMudmFsdWUpIDogdGhpcy52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVqZWN0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb25FcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0MiA9IG9uRXJyb3IodGhpcy5lcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVzdWx0MiBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAoX3Jlc3VsdDIucmVzb2x2ZWQgfHwgX3Jlc3VsdDIucmVqZWN0ZWQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZVJlc3VsdCA9IF9yZXN1bHQyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc3VsdC5yZXNvbHZlZCA/IHByb21pc2UucmVzb2x2ZShwcm9taXNlUmVzdWx0LnZhbHVlKSA6IHByb21pc2UucmVqZWN0KHByb21pc2VSZXN1bHQuZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc3VsdC5lcnJvckhhbmRsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdXRpbHNfaXNQcm9taXNlKF9yZXN1bHQyKSA/IF9yZXN1bHQyIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlICYmIChfcmVzdWx0Mi5yZXNvbHZlZCB8fCBfcmVzdWx0Mi5yZWplY3RlZCkgPyBfcmVzdWx0Mi5yZXNvbHZlZCA/IHByb21pc2UucmVzb2x2ZShfcmVzdWx0Mi52YWx1ZSkgOiBwcm9taXNlLnJlamVjdChfcmVzdWx0Mi5lcnJvcikgOiBjaGFpbihfcmVzdWx0MiwgcHJvbWlzZSkgOiBwcm9taXNlLnJlc29sdmUoX3Jlc3VsdDIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5sZW5ndGggPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbihvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChvblN1Y2Nlc3MgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvblN1Y2Nlc3MgJiYgIW9uU3VjY2Vzcy5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRoZW4gZXhwZWN0ZWQgYSBmdW5jdGlvbiBmb3Igc3VjY2VzcyBoYW5kbGVyXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKG9uRXJyb3IgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvbkVycm9yICYmICFvbkVycm9yLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudGhlbiBleHBlY3RlZCBhIGZ1bmN0aW9uIGZvciBlcnJvciBoYW5kbGVyXCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuXHQgICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogb25TdWNjZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3Jcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5jYXRjaCA9IGZ1bmN0aW9uKG9uRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCBvbkVycm9yKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmZpbmFsbHkgPSBmdW5jdGlvbihvbkZpbmFsbHkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChvbkZpbmFsbHkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvbkZpbmFsbHkgJiYgIW9uRmluYWxseS5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLmZpbmFsbHkgZXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UudHJ5KG9uRmluYWxseSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnRyeShvbkZpbmFsbHkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udGltZW91dCA9IGZ1bmN0aW9uKHRpbWUsIGVycikge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMzLnJlc29sdmVkIHx8IF90aGlzMy5yZWplY3RlZCB8fCBfdGhpczMucmVqZWN0KGVyciB8fCBuZXcgRXJyb3IoXCJQcm9taXNlIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWUgKyBcIm1zXCIpKTtcblx0ICAgICAgICAgICAgICAgIH0pLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udG9Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgUHJvbWlzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvdWxkIG5vdCBmaW5kIFByb21pc2VcIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8ubGF6eSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSA/IHZhbHVlIDogdXRpbHNfaXNQcm9taXNlKHZhbHVlKSA/IG5ldyBaYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICB9KSkgOiAobmV3IFphbGdvUHJvbWlzZSkucmVzb2x2ZSh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgWmFsZ29Qcm9taXNlKS5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuYXN5bmNSZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgWmFsZ29Qcm9taXNlKS5hc3luY1JlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5hbGwgPSBmdW5jdGlvbihwcm9taXNlcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gcHJvbWlzZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXS5zbGljZSgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBjaGFpbiA9IGZ1bmN0aW9uKGksIGZpcnN0UHJvbWlzZSwgc2Vjb25kUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdFByb21pc2UudGhlbigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDAgPT0gKGNvdW50IC09IDEpICYmIHByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb20gPSBwcm9taXNlc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvbSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbS5yZXNvbHZlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHByb20udmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF1dGlsc19pc1Byb21pc2UocHJvbSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHByb207XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjaGFpbihpLCBaYWxnb1Byb21pc2UucmVzb2x2ZShwcm9tKSwgcHJvbWlzZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAwID09PSBjb3VudCAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmhhc2ggPSBmdW5jdGlvbihwcm9taXNlcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgICAgICAgICAgICAgdmFyIGF3YWl0UHJvbWlzZXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb21pc2VzW2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzX2lzUHJvbWlzZSh2YWx1ZSkgPyBhd2FpdFByb21pc2VzLnB1c2godmFsdWUudGhlbigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSA6IHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9taXNlcykgX2xvb3Aoa2V5KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UuYWxsKGF3YWl0UHJvbWlzZXMpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5tYXAgPSBmdW5jdGlvbihpdGVtcywgbWV0aG9kKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLmFsbChpdGVtcy5tYXAobWV0aG9kKSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5vblBvc3NpYmx5VW5oYW5kbGVkRXhjZXB0aW9uID0gZnVuY3Rpb24oaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5zcGxpY2UocG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfShoYW5kbGVyKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnRyeSA9IGZ1bmN0aW9uKG1ldGhvZCwgY29udGV4dCwgYXJncykge1xuXHQgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG1ldGhvZCAmJiAhbWV0aG9kLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudHJ5IGV4cGVjdGVkIGEgZnVuY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MgfHwgW10pO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uKF9kZWxheSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBaYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIF9kZWxheSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5pc1Byb21pc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB8fCB1dGlsc19pc1Byb21pc2UodmFsdWUpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuZmx1c2ggPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihaYWxnbykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZmx1c2hQcm9taXNlID0gZmx1c2hQcm9taXNlIHx8IG5ldyBaYWxnbztcblx0ICAgICAgICAgICAgICAgICAgICBmbHVzaEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgfShaYWxnb1Byb21pc2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgIH0oKTtcblx0ICAgICAgICBmdW5jdGlvbiB1dGlsX3NhZmVJbmRleE9mKGNvbGxlY3Rpb24sIGl0ZW0pIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25baV0gPT09IGl0ZW0pIHJldHVybiBpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBDcm9zc0RvbWFpblNhZmVXZWFrTWFwKCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy53ZWFrbWFwID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5rZXlzID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBcIl9fd2Vha21hcF9cIiArICgxZTkgKiBNYXRoLnJhbmRvbSgpID4+PiAwKSArIFwiX19cIjtcblx0ICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IE9iamVjdC5mcmVlemUpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdFdlYWtNYXAgPSBuZXcgV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RLZXkgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0ZXN0S2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGVzdFdlYWtNYXAuc2V0KHRlc3RLZXksIFwiX190ZXN0dmFsdWVfX1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiX190ZXN0dmFsdWVfX1wiID09PSB0ZXN0V2Vha01hcC5nZXQodGVzdEtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KCkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWFrbWFwID0gbmV3IFdlYWtNYXA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLmtleXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9wcm90byA9IENyb3NzRG9tYWluU2FmZVdlYWtNYXAucHJvdG90eXBlO1xuXHQgICAgICAgICAgICBfcHJvdG8uX2NsZWFudXBDbG9zZWRXaW5kb3dzID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0ga2V5c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3codmFsdWUpICYmIGlzV2luZG93Q2xvc2VkKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuZGVsZXRlKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uaXNTYWZlVG9SZWFkV3JpdGUgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhaXNXaW5kb3coa2V5KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGV4cGVjdGVkIGtleVwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgd2Vha21hcC5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbbmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdID0gdmFsdWUgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkoa2V5LCBuYW1lLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbIGtleSwgdmFsdWUgXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZihrZXlzLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKC0xID09PSBpbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGV4cGVjdGVkIGtleVwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXAuaGFzKGtleSkpIHJldHVybiB3ZWFrbWFwLmdldChrZXkpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA6IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB1dGlsX3NhZmVJbmRleE9mKHRoaXMua2V5cywga2V5KTtcblx0ICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaW5kZXgpIHJldHVybiB0aGlzLnZhbHVlc1tpbmRleF07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5kZWxldGUgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGV4cGVjdGVkIGtleVwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgd2Vha21hcC5kZWxldGUoa2V5KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgJiYgKGVudHJ5WzBdID0gZW50cnlbMV0gPSB2b2lkIDApO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZihrZXlzLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKC0xICE9PSBpbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleXMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uaGFzID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwLmhhcyhrZXkpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gISghZW50cnkgfHwgZW50cnlbMF0gIT09IGtleSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xICE9PSB1dGlsX3NhZmVJbmRleE9mKHRoaXMua2V5cywga2V5KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldE9yU2V0ID0gZnVuY3Rpb24oa2V5LCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSByZXR1cm4gdGhpcy5nZXQoa2V5KTtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldHRlcigpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBDcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuXHQgICAgICAgIH0oKTtcblx0ICAgICAgICBmdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZuLm5hbWUgfHwgZm4uX19uYW1lX18gfHwgZm4uZGlzcGxheU5hbWUgfHwgXCJhbm9ueW1vdXNcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0RnVuY3Rpb25OYW1lKGZuLCBuYW1lKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZm4ubmFtZTtcblx0ICAgICAgICAgICAgICAgIGZuLm5hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIGZuLl9fbmFtZV9fID0gZm4uZGlzcGxheU5hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgICByZXR1cm4gZm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHVuaXF1ZUlEKCkge1xuXHQgICAgICAgICAgICB2YXIgY2hhcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcblx0ICAgICAgICAgICAgcmV0dXJuIFwidWlkX1wiICsgXCJ4eHh4eHh4eHh4XCIucmVwbGFjZSgvLi9nLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpO1xuXHQgICAgICAgICAgICB9KSkgKyBcIl9cIiArIGZ1bmN0aW9uKHN0cikge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYnRvYSkgcmV0dXJuIGJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgKGZ1bmN0aW9uKG0sIHAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocDEsIDE2KSk7XG5cdCAgICAgICAgICAgICAgICB9KSkpLnJlcGxhY2UoL1s9XS9nLCBcIlwiKTtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBCdWZmZXIpIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKS5yZXBsYWNlKC9bPV0vZywgXCJcIik7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgd2luZG93LmJ0b2Egb3IgQnVmZmVyXCIpO1xuXHQgICAgICAgICAgICB9KChuZXcgRGF0ZSkudG9JU09TdHJpbmcoKS5zbGljZSgxMSwgMTkpLnJlcGxhY2UoXCJUXCIsIFwiLlwiKSkucmVwbGFjZSgvW15hLXpBLVowLTldL2csIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBvYmplY3RJRHM7XG5cdCAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplQXJncyhhcmdzKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoW10uc2xpY2UuY2FsbChhcmdzKSwgKGZ1bmN0aW9uKHN1YmtleSwgdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gXCJtZW1vaXplW1wiICsgZnVuY3Rpb24ob2JqKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdElEcyA9IG9iamVjdElEcyB8fCBuZXcgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSBvYmogfHwgXCJvYmplY3RcIiAhPSB0eXBlb2Ygb2JqICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb2JqKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9iamVjdFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9IG9iamVjdElEcy5nZXQob2JqKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1aWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZCA9IHR5cGVvZiBvYmogKyBcIjpcIiArIHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMuc2V0KG9iaiwgdWlkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdWlkO1xuXHQgICAgICAgICAgICAgICAgICAgIH0odmFsKSArIFwiXVwiIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIHZhbCBpbnN0YW5jZW9mIHdpbmRvdy5FbGVtZW50IHx8IG51bGwgIT09IHZhbCAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWwgJiYgMSA9PT0gdmFsLm5vZGVUeXBlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbC5zdHlsZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWwub3duZXJEb2N1bWVudCA/IHt9IDogdmFsO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50cyBub3Qgc2VyaWFsaXphYmxlIC0tIGNhbiBub3QgYmUgdXNlZCB0byBtZW1vaXplXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEVtcHR5T2JqZWN0KCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBtZW1vaXplR2xvYmFsSW5kZXggPSAwO1xuXHQgICAgICAgIHZhciBtZW1vaXplR2xvYmFsSW5kZXhWYWxpZEZyb20gPSAwO1xuXHQgICAgICAgIGZ1bmN0aW9uIG1lbW9pemUobWV0aG9kLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0aW9ucyAmJiAob3B0aW9ucyA9IHt9KTtcblx0ICAgICAgICAgICAgdmFyIF9vcHRpb25zJHRoaXNOYW1lc3BhYyA9IG9wdGlvbnMudGhpc05hbWVzcGFjZSwgdGhpc05hbWVzcGFjZSA9IHZvaWQgMCAhPT0gX29wdGlvbnMkdGhpc05hbWVzcGFjICYmIF9vcHRpb25zJHRoaXNOYW1lc3BhYywgY2FjaGVUaW1lID0gb3B0aW9ucy50aW1lO1xuXHQgICAgICAgICAgICB2YXIgc2ltcGxlQ2FjaGU7XG5cdCAgICAgICAgICAgIHZhciB0aGlzQ2FjaGU7XG5cdCAgICAgICAgICAgIHZhciBtZW1vaXplSW5kZXggPSBtZW1vaXplR2xvYmFsSW5kZXg7XG5cdCAgICAgICAgICAgIG1lbW9pemVHbG9iYWxJbmRleCArPSAxO1xuXHQgICAgICAgICAgICB2YXIgbWVtb2l6ZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgICAgICAgICAgICAgaWYgKG1lbW9pemVJbmRleCA8IG1lbW9pemVHbG9iYWxJbmRleFZhbGlkRnJvbSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHNpbXBsZUNhY2hlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzQ2FjaGUgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIG1lbW9pemVJbmRleCA9IG1lbW9pemVHbG9iYWxJbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICBtZW1vaXplR2xvYmFsSW5kZXggKz0gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBjYWNoZTtcblx0ICAgICAgICAgICAgICAgIGNhY2hlID0gdGhpc05hbWVzcGFjZSA/ICh0aGlzQ2FjaGUgPSB0aGlzQ2FjaGUgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcCkuZ2V0T3JTZXQodGhpcywgZ2V0RW1wdHlPYmplY3QpIDogc2ltcGxlQ2FjaGUgPSBzaW1wbGVDYWNoZSB8fCB7fTtcblx0ICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXkgPSBzZXJpYWxpemVBcmdzKGFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBjYWNoZVJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcblx0ICAgICAgICAgICAgICAgIGlmIChjYWNoZVJlc3VsdCAmJiBjYWNoZVRpbWUgJiYgRGF0ZS5ub3coKSAtIGNhY2hlUmVzdWx0LnRpbWUgPCBjYWNoZVRpbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVbY2FjaGVLZXldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhY2hlUmVzdWx0ID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChjYWNoZVJlc3VsdCkgcmV0dXJuIGNhY2hlUmVzdWx0LnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIG1lbW9pemVkRnVuY3Rpb24ucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHNpbXBsZUNhY2hlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIHRoaXNDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUobWVtb2l6ZWRGdW5jdGlvbiwgKG9wdGlvbnMubmFtZSB8fCBnZXRGdW5jdGlvbk5hbWUobWV0aG9kKSkgKyBcIjo6bWVtb2l6ZWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG1lbW9pemUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZVByb21pc2UobWV0aG9kKSB7XG5cdCAgICAgICAgICAgIHZhciBjYWNoZSA9IHt9O1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBtZW1vaXplZFByb21pc2VGdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzLCBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXkgPSBzZXJpYWxpemVBcmdzKGFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybiBjYWNoZVtrZXldO1xuXHQgICAgICAgICAgICAgICAgY2FjaGVba2V5XSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShfdGhpcywgX2FyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICB9KSkuZmluYWxseSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVba2V5XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBtZW1vaXplZFByb21pc2VGdW5jdGlvbi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgY2FjaGUgPSB7fTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldEZ1bmN0aW9uTmFtZShtZW1vaXplZFByb21pc2VGdW5jdGlvbiwgZ2V0RnVuY3Rpb25OYW1lKG1ldGhvZCkgKyBcIjo6cHJvbWlzZU1lbW9pemVkXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzcmNfdXRpbF9ub29wKCkge31cblx0ICAgICAgICBmdW5jdGlvbiBzdHJpbmdpZnlFcnJvcihlcnIsIGxldmVsKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gbGV2ZWwgJiYgKGxldmVsID0gMSk7XG5cdCAgICAgICAgICAgIGlmIChsZXZlbCA+PSAzKSByZXR1cm4gXCJzdHJpbmdpZnlFcnJvciBzdGFjayBvdmVyZmxvd1wiO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHJldHVybiBcIjx1bmtub3duIGVycm9yOiBcIiArIHt9LnRvU3RyaW5nLmNhbGwoZXJyKSArIFwiPlwiO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGVycikgcmV0dXJuIGVycjtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGVyciAmJiBlcnIuc3RhY2s7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrICYmIG1lc3NhZ2UpIHJldHVybiAtMSAhPT0gc3RhY2suaW5kZXhPZihtZXNzYWdlKSA/IHN0YWNrIDogbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2spIHJldHVybiBzdGFjaztcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkgcmV0dXJuIG1lc3NhZ2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZXJyICYmIGVyci50b1N0cmluZyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGVyci50b1N0cmluZyA/IGVyci50b1N0cmluZygpIDoge30udG9TdHJpbmcuY2FsbChlcnIpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChuZXdFcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yIHdoaWxlIHN0cmluZ2lmeWluZyBlcnJvcjogXCIgKyBzdHJpbmdpZnlFcnJvcihuZXdFcnIsIGxldmVsICsgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGl0ZW0gPyBpdGVtIDogaXRlbS50b1N0cmluZyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0udG9TdHJpbmcgPyBpdGVtLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtZW1vaXplKChmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMpIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgb2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgcmVzdWx0LnB1c2gob2JqW2tleV0pO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBmdW5jdGlvbiB1dGlsX2lzUmVnZXgoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbF9nZXRPclNldChvYmosIGtleSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIG9ialtrZXldO1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gZ2V0dGVyKCk7XG5cdCAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuXHQgICAgICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cdCAgICAgICAgICAgIGlmICghYm9keSkgdGhyb3cgbmV3IEVycm9yKFwiQm9keSBlbGVtZW50IG5vdCBmb3VuZFwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRSZWFkeSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZG9jdW1lbnQuYm9keSkgJiYgXCJjb21wbGV0ZVwiID09PSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGRvY3VtZW50LmJvZHkpICYmIFwiaW50ZXJhY3RpdmVcIiA9PT0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50UmVhZHkoKSB8fCBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSkgcmV0dXJuIHJlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkgfHwgaXNEb2N1bWVudEludGVyYWN0aXZlKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSksIDEwKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICB2YXIgY3VycmVudFNjcmlwdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGRvY3VtZW50ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdCA6IG51bGw7XG5cdCAgICAgICAgdmFyIGdldEN1cnJlbnRTY3JpcHQgPSBtZW1vaXplKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JpcHQpIHJldHVybiBjdXJyZW50U2NyaXB0O1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFNjcmlwdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyci5zdGFjayB8fCBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFja0RldGFpbHMgPSAvLiphdCBbXihdKlxcKCguKik6KC4rKTooLispXFwpJC9naS5leGVjKHN0YWNrKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0TG9jYXRpb24gPSBzdGFja0RldGFpbHMgJiYgc3RhY2tEZXRhaWxzWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2NyaXB0TG9jYXRpb24pIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIyID0gMCwgX0FycmF5JHByb3RvdHlwZSRzbGljMiA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIikpLnJldmVyc2UoKTsgX2kyMiA8IF9BcnJheSRwcm90b3R5cGUkc2xpYzIubGVuZ3RoOyBfaTIyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcmlwdCA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbX2kyMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JpcHQuc3JjICYmIHNjcmlwdC5zcmMgPT09IHNjcmlwdExvY2F0aW9uKSByZXR1cm4gc2NyaXB0O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfSgpKSByZXR1cm4gY3VycmVudFNjcmlwdDtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXRlcm1pbmUgY3VycmVudCBzY3JpcHRcIik7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIHZhciBjdXJyZW50VUlEID0gdW5pcXVlSUQoKTtcblx0ICAgICAgICBtZW1vaXplKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHNjcmlwdDtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHNjcmlwdCA9IGdldEN1cnJlbnRTY3JpcHQoKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFVJRDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgdWlkID0gc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtdWlkXCIpO1xuXHQgICAgICAgICAgICBpZiAodWlkICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHVpZCkgcmV0dXJuIHVpZDtcblx0ICAgICAgICAgICAgaWYgKCh1aWQgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS11aWQtYXV0b1wiKSkgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdWlkKSByZXR1cm4gdWlkO1xuXHQgICAgICAgICAgICBpZiAoc2NyaXB0LnNyYykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhhc2hlZFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSBzdHJbaV0uY2hhckNvZGVBdCgwKSAqIGk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cltpICsgMV0gJiYgKHRvdGFsICs9IHN0cltpICsgMV0uY2hhckNvZGVBdCgwKSAqIChpIC0gMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBNYXRoLmFicyh0b3RhbCkgJSAyNik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgICAgICAgICAgfShKU09OLnN0cmluZ2lmeSh7XG5cdCAgICAgICAgICAgICAgICAgICAgc3JjOiBzY3JpcHQuc3JjLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFzZXQ6IHNjcmlwdC5kYXRhc2V0XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB1aWQgPSBcInVpZF9cIiArIGhhc2hlZFN0cmluZy5zbGljZShoYXNoZWRTdHJpbmcubGVuZ3RoIC0gMzApO1xuXHQgICAgICAgICAgICB9IGVsc2UgdWlkID0gdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZShcImRhdGEtdWlkLWF1dG9cIiwgdWlkKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHVpZDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gZ2xvYmFsX2dldEdsb2JhbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHZhciBnbG9iYWxLZXkgPSBcIl9fcG9zdF9yb2JvdF8xMF8wXzQ2X19cIjtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbiAhPT0gd2luZG93ID8gd2luW2dsb2JhbEtleV0gOiB3aW5bZ2xvYmFsS2V5XSA9IHdpbltnbG9iYWxLZXldIHx8IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZ2V0T2JqID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIGdsb2JhbFN0b3JlKGtleSwgZGVmU3RvcmUpIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBrZXkgJiYgKGtleSA9IFwic3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVmU3RvcmUgJiYgKGRlZlN0b3JlID0gZ2V0T2JqKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoZ2xvYmFsX2dldEdsb2JhbCgpLCBrZXksIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IGRlZlN0b3JlKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24oc3RvcmVLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmhhc093blByb3BlcnR5KHN0b3JlS2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oc3RvcmVLZXksIGRlZlZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuaGFzT3duUHJvcGVydHkoc3RvcmVLZXkpID8gc3RvcmVbc3RvcmVLZXldIDogZGVmVmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihzdG9yZUtleSwgdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3N0b3JlS2V5XSA9IHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGRlbDogZnVuY3Rpb24oc3RvcmVLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0b3JlW3N0b3JlS2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldE9yU2V0OiBmdW5jdGlvbihzdG9yZUtleSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsX2dldE9yU2V0KHN0b3JlLCBzdG9yZUtleSwgZ2V0dGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSBkZWZTdG9yZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdG9yZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgV2lsZENhcmQgPSBmdW5jdGlvbigpIHt9O1xuXHQgICAgICAgIGZ1bmN0aW9uIGdldFdpbGRjYXJkKCkge1xuXHQgICAgICAgICAgICB2YXIgZ2xvYmFsID0gZ2xvYmFsX2dldEdsb2JhbCgpO1xuXHQgICAgICAgICAgICBnbG9iYWwuV0lORE9XX1dJTERDQVJEID0gZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCB8fCBuZXcgV2lsZENhcmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWwuV0lORE9XX1dJTERDQVJEO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB3aW5kb3dTdG9yZShrZXksIGRlZlN0b3JlKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0ga2V5ICYmIChrZXkgPSBcInN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGRlZlN0b3JlICYmIChkZWZTdG9yZSA9IGdldE9iaik7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcIndpbmRvd1N0b3JlXCIpLmdldE9yU2V0KGtleSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpblN0b3JlID0gbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgIHZhciBnZXRTdG9yZSA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5TdG9yZS5nZXRPclNldCh3aW4sIGRlZlN0b3JlKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRTdG9yZSh3aW4pLmhhc093blByb3BlcnR5KGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKHdpbiwgZGVmVmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IGdldFN0b3JlKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShrZXkpID8gc3RvcmVba2V5XSA6IGRlZlZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24od2luLCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RvcmUod2luKVtrZXldID0gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsOiBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdldFN0b3JlKHdpbilba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldE9yU2V0OiBmdW5jdGlvbih3aW4sIGdldHRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF9nZXRPclNldChnZXRTdG9yZSh3aW4pLCBrZXksIGdldHRlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRJbnN0YW5jZUlEKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJpbnN0YW5jZVwiKS5nZXRPclNldChcImluc3RhbmNlSURcIiwgdW5pcXVlSUQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiByZXNvbHZlSGVsbG9Qcm9taXNlKHdpbiwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgZG9tYWluID0gX3JlZi5kb21haW47XG5cdCAgICAgICAgICAgIHZhciBoZWxsb1Byb21pc2VzID0gd2luZG93U3RvcmUoXCJoZWxsb1Byb21pc2VzXCIpO1xuXHQgICAgICAgICAgICB2YXIgZXhpc3RpbmdQcm9taXNlID0gaGVsbG9Qcm9taXNlcy5nZXQod2luKTtcblx0ICAgICAgICAgICAgZXhpc3RpbmdQcm9taXNlICYmIGV4aXN0aW5nUHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB2YXIgbmV3UHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUoe1xuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGhlbGxvUHJvbWlzZXMuc2V0KHdpbiwgbmV3UHJvbWlzZSk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdQcm9taXNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzYXlIZWxsbyh3aW4sIF9yZWY0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgX3JlZjQuc2VuZCkod2luLCBcInBvc3Ryb2JvdF9oZWxsb1wiLCB7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBnZXRJbnN0YW5jZUlEKClcblx0ICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBcIipcIixcblx0ICAgICAgICAgICAgICAgIHRpbWVvdXQ6IC0xXG5cdCAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gX3JlZjUub3JpZ2luLCBpbnN0YW5jZUlEID0gX3JlZjUuZGF0YS5pbnN0YW5jZUlEO1xuXHQgICAgICAgICAgICAgICAgcmVzb2x2ZUhlbGxvUHJvbWlzZSh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpblxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSUQ6IGluc3RhbmNlSURcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0V2luZG93SW5zdGFuY2VJRCh3aW4sIF9yZWY2KSB7XG5cdCAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjYuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwid2luZG93SW5zdGFuY2VJRFByb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNheUhlbGxvKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY3KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY3Lmluc3RhbmNlSUQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbWFya1dpbmRvd0tub3duKHdpbikge1xuXHQgICAgICAgICAgICB3aW5kb3dTdG9yZShcImtub3duV2luZG93c1wiKS5zZXQod2luLCB0cnVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNTZXJpYWxpemVkVHlwZShpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiBpdGVtICYmIG51bGwgIT09IGl0ZW0gJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgaXRlbS5fX3R5cGVfXztcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGV0ZXJtaW5lVHlwZSh2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdmFsID8gXCJ1bmRlZmluZWRcIiA6IG51bGwgPT09IHZhbCA/IFwibnVsbFwiIDogQXJyYXkuaXNBcnJheSh2YWwpID8gXCJhcnJheVwiIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwgPyBcImZ1bmN0aW9uXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWwgPyB2YWwgaW5zdGFuY2VvZiBFcnJvciA/IFwiZXJyb3JcIiA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsLnRoZW4gPyBcInByb21pc2VcIiA6IFwiW29iamVjdCBSZWdFeHBdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwodmFsKSA/IFwicmVnZXhcIiA6IFwiW29iamVjdCBEYXRlXVwiID09PSB7fS50b1N0cmluZy5jYWxsKHZhbCkgPyBcImRhdGVcIiA6IFwib2JqZWN0XCIgOiBcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgPyBcInN0cmluZ1wiIDogXCJudW1iZXJcIiA9PSB0eXBlb2YgdmFsID8gXCJudW1iZXJcIiA6IFwiYm9vbGVhblwiID09IHR5cGVvZiB2YWwgPyBcImJvb2xlYW5cIiA6IHZvaWQgMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplVHlwZSh0eXBlLCB2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIF9fdHlwZV9fOiB0eXBlLFxuXHQgICAgICAgICAgICAgICAgX192YWxfXzogdmFsXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBfU0VSSUFMSVpFUjtcblx0ICAgICAgICB2YXIgU0VSSUFMSVpFUiA9ICgoX1NFUklBTElaRVIgPSB7fSkuZnVuY3Rpb24gPSBmdW5jdGlvbigpIHt9LCBfU0VSSUFMSVpFUi5lcnJvciA9IGZ1bmN0aW9uKF9yZWYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJlcnJvclwiLCB7XG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlOiBfcmVmLm1lc3NhZ2UsXG5cdCAgICAgICAgICAgICAgICBzdGFjazogX3JlZi5zdGFjayxcblx0ICAgICAgICAgICAgICAgIGNvZGU6IF9yZWYuY29kZSxcblx0ICAgICAgICAgICAgICAgIGRhdGE6IF9yZWYuZGF0YVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5wcm9taXNlID0gZnVuY3Rpb24oKSB7fSwgX1NFUklBTElaRVIucmVnZXggPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJyZWdleFwiLCB2YWwuc291cmNlKTtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5kYXRlID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwiZGF0ZVwiLCB2YWwudG9KU09OKCkpO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLmFycmF5ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIub2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIuc3RyaW5nID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIubnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIuYm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLm51bGwgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUlt2b2lkIDBdID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwidW5kZWZpbmVkXCIsIHZhbCk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIpO1xuXHQgICAgICAgIHZhciBkZWZhdWx0U2VyaWFsaXplcnMgPSB7fTtcblx0ICAgICAgICB2YXIgX0RFU0VSSUFMSVpFUjtcblx0ICAgICAgICB2YXIgREVTRVJJQUxJWkVSID0gKChfREVTRVJJQUxJWkVSID0ge30pLmZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHNlcmlhbGl6YXRpb24gaXMgbm90IGltcGxlbWVudGVkOyBub3RoaW5nIHRvIGRlc2VyaWFsaXplXCIpO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuZXJyb3IgPSBmdW5jdGlvbihfcmVmMikge1xuXHQgICAgICAgICAgICB2YXIgc3RhY2sgPSBfcmVmMi5zdGFjaywgY29kZSA9IF9yZWYyLmNvZGUsIGRhdGEgPSBfcmVmMi5kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoX3JlZjIubWVzc2FnZSk7XG5cdCAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuXHQgICAgICAgICAgICBkYXRhICYmIChlcnJvci5kYXRhID0gZGF0YSk7XG5cdCAgICAgICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2sgKyBcIlxcblxcblwiICsgZXJyb3Iuc3RhY2s7XG5cdCAgICAgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLnByb21pc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBzZXJpYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZDsgbm90aGluZyB0byBkZXNlcmlhbGl6ZVwiKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLnJlZ2V4ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHZhbCk7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5kYXRlID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWwpO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuYXJyYXkgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuc3RyaW5nID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5udW1iZXIgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmJvb2xlYW4gPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm51bGwgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSW3ZvaWQgMF0gPSBmdW5jdGlvbigpIHt9LCBfREVTRVJJQUxJWkVSKTtcblx0ICAgICAgICB2YXIgZGVmYXVsdERlc2VyaWFsaXplcnMgPSB7fTtcblx0ICAgICAgICBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keSkgcmV0dXJuIHJlc29sdmUod2luZG93LmRvY3VtZW50LmJvZHkpO1xuXHQgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUod2luZG93LmRvY3VtZW50LmJvZHkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KSwgMTApO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBmdW5jdGlvbiBjbGVhbnVwUHJveHlXaW5kb3dzKCkge1xuXHQgICAgICAgICAgICB2YXIgaWRUb1Byb3h5V2luZG93ID0gZ2xvYmFsU3RvcmUoXCJpZFRvUHJveHlXaW5kb3dcIik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9pZFRvUHJveHlXaW5kb3cka2V5czIgPSBpZFRvUHJveHlXaW5kb3cua2V5cygpOyBfaTIgPCBfaWRUb1Byb3h5V2luZG93JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpZCA9IF9pZFRvUHJveHlXaW5kb3cka2V5czJbX2kyXTtcblx0ICAgICAgICAgICAgICAgIGlkVG9Qcm94eVdpbmRvdy5nZXQoaWQpLnNob3VsZENsZWFuKCkgJiYgaWRUb1Byb3h5V2luZG93LmRlbChpZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0U2VyaWFsaXplZFdpbmRvdyh3aW5Qcm9taXNlLCBfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZi5zZW5kLCBfcmVmJGlkID0gX3JlZi5pZCwgaWQgPSB2b2lkIDAgPT09IF9yZWYkaWQgPyB1bmlxdWVJRCgpIDogX3JlZiRpZDtcblx0ICAgICAgICAgICAgdmFyIHdpbmRvd05hbWVQcm9taXNlID0gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1NhbWVEb21haW4od2luKSkgcmV0dXJuIGFzc2VydFNhbWVEb21haW4od2luKS5uYW1lO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHZhciB3aW5kb3dUeXBlUHJvbWlzZSA9IHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luZG93KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luZG93KSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IGlzIGNsb3NlZCwgY2FuIG5vdCBkZXRlcm1pbmUgdHlwZVwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBnZXRPcGVuZXIod2luZG93KSA/IFwicG9wdXBcIiA6IFwiaWZyYW1lXCI7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgd2luZG93TmFtZVByb21pc2UuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgICAgIHdpbmRvd1R5cGVQcm9taXNlLmNhdGNoKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgICAgICB2YXIgZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1dpbmRvd0Nsb3NlZCh3aW4pKSByZXR1cm4gaXNTYW1lRG9tYWluKHdpbikgPyBhc3NlcnRTYW1lRG9tYWluKHdpbikubmFtZSA6IHdpbmRvd05hbWVQcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1R5cGVQcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGdldEluc3RhbmNlSUQ6IG1lbW9pemVQcm9taXNlKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvd0luc3RhbmNlSUQod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKSxcblx0ICAgICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKGNsb3NlV2luZG93KTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBnZXROYW1lOiBnZXROYW1lLFxuXHQgICAgICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4uZm9jdXMoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgaXNDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNXaW5kb3dDbG9zZWQod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgc2V0TG9jYXRpb246IGZ1bmN0aW9uKGhyZWYsIG9wdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG9wdHMgJiYgKG9wdHMgPSB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9vcHRzJG1ldGhvZCA9IG9wdHMubWV0aG9kLCBtZXRob2QgPSB2b2lkIDAgPT09IF9vcHRzJG1ldGhvZCA/IFwiZ2V0XCIgOiBfb3B0cyRtZXRob2QsIGJvZHkgPSBvcHRzLmJvZHk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBocmVmLmluZGV4T2YoXCIvXCIpKSBocmVmID0gXCJcIiArIGRvbWFpbiArIGhyZWY7IGVsc2UgaWYgKCFocmVmLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy8pICYmIDAgIT09IGhyZWYuaW5kZXhPZihkb21haW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB1cmwgdG8gYmUgaHR0cCBvciBodHRwcyB1cmwsIG9yIGFic29sdXRlIHBhdGgsIGdvdCBcIiArIEpTT04uc3RyaW5naWZ5KGhyZWYpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwicG9zdFwiID09PSBtZXRob2QpIHJldHVybiBnZXROYW1lKCkudGhlbigoZnVuY3Rpb24obmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHBvc3QgdG8gd2luZG93IHdpdGhvdXQgdGFyZ2V0IG5hbWVcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oX3JlZjMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gX3JlZjMudXJsLCB0YXJnZXQgPSBfcmVmMy50YXJnZXQsIGJvZHkgPSBfcmVmMy5ib2R5LCBfcmVmMyRtZXRob2QgPSBfcmVmMy5tZXRob2QsIG1ldGhvZCA9IHZvaWQgMCA9PT0gX3JlZjMkbWV0aG9kID8gXCJwb3N0XCIgOiBfcmVmMyRtZXRob2Q7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCB0YXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwibWV0aG9kXCIsIG1ldGhvZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIiwgdXJsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSkgZm9yICh2YXIgX2kyNCA9IDAsIF9PYmplY3Qka2V5czQgPSBPYmplY3Qua2V5cyhib2R5KTsgX2kyNCA8IF9PYmplY3Qka2V5czQubGVuZ3RoOyBfaTI0KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9ib2R5JGtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9PYmplY3Qka2V5czRbX2kyNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBudWxsID09IChfYm9keSRrZXkgPSBib2R5W2tleV0pID8gdm9pZCAwIDogX2JvZHkka2V5LnRvU3RyaW5nKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Qm9keSgpLmFwcGVuZENoaWxkKGZvcm0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Qm9keSgpLnJlbW92ZUNoaWxkKGZvcm0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBocmVmLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJnZXRcIiAhPT0gbWV0aG9kKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBtZXRob2Q6IFwiICsgbWV0aG9kKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbi5sb2NhdGlvbiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbi5sb2NhdGlvbi5yZXBsYWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luLmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5sb2NhdGlvbiA9IGhyZWY7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhbWVEb21haW4gPSBpc1NhbWVEb21haW4od2luKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gZ2V0RnJhbWVGb3JXaW5kb3cod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHNldCBuYW1lIGZvciBjcm9zcy1kb21haW4gd2luZG93OiBcIiArIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRTYW1lRG9tYWluKHdpbikubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lICYmIGZyYW1lLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgbmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWVQcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UucmVzb2x2ZShuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB3aW5kb3dfUHJveHlXaW5kb3cgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gUHJveHlXaW5kb3coX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjIuc2VuZCwgd2luID0gX3JlZjIud2luLCBzZXJpYWxpemVkV2luZG93ID0gX3JlZjIuc2VyaWFsaXplZFdpbmRvdztcblx0ICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlzUHJveHlXaW5kb3cgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3cgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlbmQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UgPSBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cgPSBzZXJpYWxpemVkV2luZG93IHx8IGdldFNlcmlhbGl6ZWRXaW5kb3codGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKS5zZXQodGhpcy5nZXRJRCgpLCB0aGlzKTtcblx0ICAgICAgICAgICAgICAgIHdpbiAmJiB0aGlzLnNldFdpbmRvdyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgX3Byb3RvID0gUHJveHlXaW5kb3cucHJvdG90eXBlO1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0SUQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuaWQ7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRUeXBlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldFR5cGUoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmlzUG9wdXAgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS50aGVuKChmdW5jdGlvbih0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicG9wdXBcIiA9PT0gdHlwZTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNldExvY2F0aW9uID0gZnVuY3Rpb24oaHJlZiwgb3B0cykge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuc2V0TG9jYXRpb24oaHJlZiwgb3B0cykudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5nZXROYW1lKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXROYW1lID0gZnVuY3Rpb24obmFtZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LnNldE5hbWUobmFtZSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMjtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuY2xvc2UoKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZm9jdXMgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGlzUG9wdXBQcm9taXNlID0gdGhpcy5pc1BvcHVwKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgZ2V0TmFtZVByb21pc2UgPSB0aGlzLmdldE5hbWUoKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZW9wZW5Qcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgaXNQb3B1cDogaXNQb3B1cFByb21pc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZTogZ2V0TmFtZVByb21pc2Vcblx0ICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWYzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIF9yZWYzLmlzUG9wdXAgJiYgbmFtZSAmJiB3aW5kb3cub3BlbihcIlwiLCBuYW1lLCBcIm5vb3BlbmVyXCIpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGZvY3VzUHJvbWlzZSA9IHRoaXMuc2VyaWFsaXplZFdpbmRvdy5mb2N1cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmFsbChbIHJlb3BlblByb21pc2UsIGZvY3VzUHJvbWlzZSBdKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uaXNDbG9zZWQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuaXNDbG9zZWQoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsV2luZG93O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2V0V2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmNCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNC5zZW5kO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3cgPSB3aW47XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UucmVzb2x2ZSh0aGlzLmFjdHVhbFdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cgPSBnZXRTZXJpYWxpemVkV2luZG93KHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmQsXG5cdCAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SUQoKVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB3aW5kb3dTdG9yZShcIndpblRvUHJveHlXaW5kb3dcIikuc2V0KHdpbiwgdGhpcyk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5hd2FpdFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLm1hdGNoV2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmNSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY1LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1LmFjdHVhbFdpbmRvdyA/IHdpbiA9PT0gX3RoaXM1LmFjdHVhbFdpbmRvdyA6IHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2goe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm94eUluc3RhbmNlSUQ6IF90aGlzNS5nZXRJbnN0YW5jZUlEKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtub3duV2luZG93SW5zdGFuY2VJRDogZ2V0V2luZG93SW5zdGFuY2VJRCh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmNikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBfcmVmNi5wcm94eUluc3RhbmNlSUQgPT09IF9yZWY2Lmtub3duV2luZG93SW5zdGFuY2VJRDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggJiYgX3RoaXM1LnNldFdpbmRvdyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by51bndyYXAgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdHVhbFdpbmRvdyB8fCB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0SW5zdGFuY2VJRCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5nZXRJbnN0YW5jZUlEKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zaG91bGRDbGVhbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5hY3R1YWxXaW5kb3cgJiYgaXNXaW5kb3dDbG9zZWQodGhpcy5hY3R1YWxXaW5kb3cpKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cudW53cmFwID0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh3aW4pID8gd2luLnVud3JhcCgpIDogd2luO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy5zZXJpYWxpemUgPSBmdW5jdGlvbih3aW4sIF9yZWY3KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY3LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KS5zZXJpYWxpemUoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cuZGVzZXJpYWxpemUgPSBmdW5jdGlvbihzZXJpYWxpemVkV2luZG93LCBfcmVmOCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmOC5zZW5kO1xuXHQgICAgICAgICAgICAgICAgY2xlYW51cFByb3h5V2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiaWRUb1Byb3h5V2luZG93XCIpLmdldChzZXJpYWxpemVkV2luZG93LmlkKSB8fCBuZXcgUHJveHlXaW5kb3coe1xuXHQgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRXaW5kb3c6IHNlcmlhbGl6ZWRXaW5kb3csXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LmlzUHJveHlXaW5kb3cgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKG9iaiAmJiAhaXNXaW5kb3cob2JqKSAmJiBvYmouaXNQcm94eVdpbmRvdyk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LnRvUHJveHlXaW5kb3cgPSBmdW5jdGlvbih3aW4sIF9yZWY5KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY5LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh3aW4pKSByZXR1cm4gd2luO1xuXHQgICAgICAgICAgICAgICAgdmFyIGFjdHVhbFdpbmRvdyA9IHdpbjtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcIndpblRvUHJveHlXaW5kb3dcIikuZ2V0KGFjdHVhbFdpbmRvdykgfHwgbmV3IFByb3h5V2luZG93KHtcblx0ICAgICAgICAgICAgICAgICAgICB3aW46IGFjdHVhbFdpbmRvdyxcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIFByb3h5V2luZG93O1xuXHQgICAgICAgIH0oKTtcblx0ICAgICAgICBmdW5jdGlvbiBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgc291cmNlLCBkb21haW4pIHtcblx0ICAgICAgICAgICAgdmFyIG1ldGhvZFN0b3JlID0gd2luZG93U3RvcmUoXCJtZXRob2RTdG9yZVwiKTtcblx0ICAgICAgICAgICAgdmFyIHByb3h5V2luZG93TWV0aG9kcyA9IGdsb2JhbFN0b3JlKFwicHJveHlXaW5kb3dNZXRob2RzXCIpO1xuXHQgICAgICAgICAgICBpZiAod2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3coc291cmNlKSkgcHJveHlXaW5kb3dNZXRob2RzLnNldChpZCwge1xuXHQgICAgICAgICAgICAgICAgdmFsOiB2YWwsXG5cdCAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuXHQgICAgICAgICAgICB9KTsgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwcm94eVdpbmRvd01ldGhvZHMuZGVsKGlkKTtcblx0ICAgICAgICAgICAgICAgIG1ldGhvZFN0b3JlLmdldE9yU2V0KHNvdXJjZSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgICAgIH0pKVtpZF0gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWw6IHZhbCxcblx0ICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBsb29rdXBNZXRob2Qoc291cmNlLCBpZCkge1xuXHQgICAgICAgICAgICB2YXIgbWV0aG9kU3RvcmUgPSB3aW5kb3dTdG9yZShcIm1ldGhvZFN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2YXIgcHJveHlXaW5kb3dNZXRob2RzID0gZ2xvYmFsU3RvcmUoXCJwcm94eVdpbmRvd01ldGhvZHNcIik7XG5cdCAgICAgICAgICAgIHJldHVybiBtZXRob2RTdG9yZS5nZXRPclNldChzb3VyY2UsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgfSkpW2lkXSB8fCBwcm94eVdpbmRvd01ldGhvZHMuZ2V0KGlkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZnVuY3Rpb25fc2VyaWFsaXplRnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIF9yZWYzKSB7XG5cdCAgICAgICAgICAgIG9uID0gKF9yZWYgPSB7XG5cdCAgICAgICAgICAgICAgICBvbjogX3JlZjMub24sXG5cdCAgICAgICAgICAgICAgICBzZW5kOiBfcmVmMy5zZW5kXG5cdCAgICAgICAgICAgIH0pLm9uLCBzZW5kID0gX3JlZi5zZW5kLCBnbG9iYWxTdG9yZShcImJ1aWx0aW5MaXN0ZW5lcnNcIikuZ2V0T3JTZXQoXCJmdW5jdGlvbkNhbGxzXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvbihcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogXCIqXCJcblx0ICAgICAgICAgICAgICAgIH0sIChmdW5jdGlvbihfcmVmMikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfcmVmMi5zb3VyY2UsIG9yaWdpbiA9IF9yZWYyLm9yaWdpbiwgZGF0YSA9IF9yZWYyLmRhdGE7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gZGF0YS5pZCwgbmFtZSA9IGRhdGEubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aCA9IGxvb2t1cE1ldGhvZChzb3VyY2UsIGlkKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGgpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1ldGhvZCAnXCIgKyBuYW1lICsgXCInIHdpdGggaWQ6IFwiICsgZGF0YS5pZCArIFwiIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2RTb3VyY2UgPSBtZXRoLnNvdXJjZSwgZG9tYWluID0gbWV0aC5kb21haW4sIHZhbCA9IG1ldGgudmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKGRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kICdcIiArIGRhdGEubmFtZSArIFwiJyBkb21haW4gXCIgKyBKU09OLnN0cmluZ2lmeSh1dGlsX2lzUmVnZXgobWV0aC5kb21haW4pID8gbWV0aC5kb21haW4uc291cmNlIDogbWV0aC5kb21haW4pICsgXCIgZG9lcyBub3QgbWF0Y2ggb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyBnZXREb21haW4od2luZG93KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyhtZXRob2RTb3VyY2UpKSByZXR1cm4gbWV0aG9kU291cmNlLm1hdGNoV2luZG93KHNvdXJjZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihtYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIGNhbGwgJ1wiICsgZGF0YS5uYW1lICsgXCInIGZhaWxlZCAtIHByb3h5IHdpbmRvdyBkb2VzIG5vdCBtYXRjaCBzb3VyY2UgaW4gXCIgKyBnZXREb21haW4od2luZG93KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuYXBwbHkoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBkYXRhLmFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5vbkVycm9yKSByZXR1cm4gdmFsLm9uRXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICYmIChlcnIuc3RhY2sgPSBcIlJlbW90ZSBjYWxsIHRvIFwiICsgbmFtZSArIFwiKFwiICsgZnVuY3Rpb24oYXJncykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYXJncyAmJiAoYXJncyA9IFtdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGl0ZW0gPSBhcmdzLCBbXS5zbGljZS5jYWxsKGl0ZW0pKS5tYXAoKGZ1bmN0aW9uKGFyZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgYXJnID8gXCInXCIgKyBhcmcgKyBcIidcIiA6IHZvaWQgMCA9PT0gYXJnID8gXCJ1bmRlZmluZWRcIiA6IG51bGwgPT09IGFyZyA/IFwibnVsbFwiIDogXCJib29sZWFuXCIgPT0gdHlwZW9mIGFyZyA/IGFyZy50b1N0cmluZygpIDogQXJyYXkuaXNBcnJheShhcmcpID8gXCJbIC4uLiBdXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiBhcmcgPyBcInsgLi4uIH1cIiA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYXJnID8gXCIoKSA9PiB7IC4uLiB9XCIgOiBcIjxcIiArIHR5cGVvZiBhcmcgKyBcIj5cIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihcIiwgXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShkYXRhLmFyZ3MpICsgXCIpIGZhaWxlZFxcblxcblwiICsgZXJyLnN0YWNrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB2YXIgX3JlZiwgb24sIHNlbmQ7XG5cdCAgICAgICAgICAgIHZhciBpZCA9IHZhbC5fX2lkX18gfHwgdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgZGVzdGluYXRpb24gPSB3aW5kb3dfUHJveHlXaW5kb3cudW53cmFwKGRlc3RpbmF0aW9uKTtcblx0ICAgICAgICAgICAgdmFyIG5hbWUgPSB2YWwuX19uYW1lX18gfHwgdmFsLm5hbWUgfHwga2V5O1xuXHQgICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiBuYW1lICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbmFtZS5pbmRleE9mICYmIDAgPT09IG5hbWUuaW5kZXhPZihcImFub255bW91czo6XCIpICYmIChuYW1lID0gbmFtZS5yZXBsYWNlKFwiYW5vbnltb3VzOjpcIiwga2V5ICsgXCI6OlwiKSk7XG5cdCAgICAgICAgICAgIGlmICh3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyhkZXN0aW5hdGlvbikpIHtcblx0ICAgICAgICAgICAgICAgIGFkZE1ldGhvZChpZCwgdmFsLCBuYW1lLCBkZXN0aW5hdGlvbiwgZG9tYWluKTtcblx0ICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmF3YWl0V2luZG93KCkudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIHdpbiwgZG9tYWluKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGFkZE1ldGhvZChpZCwgdmFsLCBuYW1lLCBkZXN0aW5hdGlvbiwgZG9tYWluKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5fZnVuY3Rpb25cIiwge1xuXHQgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplTWVzc2FnZShkZXN0aW5hdGlvbiwgZG9tYWluLCBvYmosIF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIF9zZXJpYWxpemU7XG5cdCAgICAgICAgICAgIHZhciBvbiA9IF9yZWYub24sIHNlbmQgPSBfcmVmLnNlbmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXJzKSB7XG5cdCAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHNlcmlhbGl6ZXJzICYmIChzZXJpYWxpemVycyA9IGRlZmF1bHRTZXJpYWxpemVycyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkob2JqLCAoZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXNba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh0aGlzKSkgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGRldGVybWluZVR5cGUodmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGUpIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc1t0eXBlXSB8fCBTRVJJQUxJWkVSW3R5cGVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVyID8gc2VyaWFsaXplcih2YWwsIGtleSkgOiB2YWw7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSByZXN1bHQgPyBcInVuZGVmaW5lZFwiIDogcmVzdWx0O1xuXHQgICAgICAgICAgICB9KG9iaiwgKChfc2VyaWFsaXplID0ge30pLnByb21pc2UgPSBmdW5jdGlvbih2YWwsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCBfcmVmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5femFsZ29fcHJvbWlzZVwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSwga2V5LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogX3JlZi5vbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IF9yZWYuc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfShkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZS5mdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25fc2VyaWFsaXplRnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9zZXJpYWxpemUub2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaXNXaW5kb3codmFsKSB8fCB3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh2YWwpID8gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl93aW5kb3dcIiwgd2luZG93X1Byb3h5V2luZG93LnNlcmlhbGl6ZSh2YWwsIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KSkgOiB2YWw7XG5cdCAgICAgICAgICAgIH0sIF9zZXJpYWxpemUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemVNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCBfcmVmMikge1xuXHQgICAgICAgICAgICB2YXIgX2Rlc2VyaWFsaXplO1xuXHQgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYyLnNlbmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdHIsIGRlc2VyaWFsaXplcnMpIHtcblx0ICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVzZXJpYWxpemVycyAmJiAoZGVzZXJpYWxpemVycyA9IGRlZmF1bHREZXNlcmlhbGl6ZXJzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSBzdHIpIHJldHVybiBKU09OLnBhcnNlKHN0ciwgKGZ1bmN0aW9uKGtleSwgdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFR5cGUodGhpcykpIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRUeXBlKHZhbCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHZhbC5fX3R5cGVfXztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWwuX192YWxfXztcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gZGV0ZXJtaW5lVHlwZSh2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2VyaWFsaXplciA9IGRlc2VyaWFsaXplcnNbdHlwZV0gfHwgREVTRVJJQUxJWkVSW3R5cGVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZXIgPyBkZXNlcmlhbGl6ZXIodmFsdWUsIGtleSkgOiB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfShtZXNzYWdlLCAoKF9kZXNlcmlhbGl6ZSA9IHt9KS5jcm9zc19kb21haW5femFsZ29fcHJvbWlzZSA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRQcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBvcmlnaW4sIF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZShfcmVmMi50aGVuKTtcblx0ICAgICAgICAgICAgICAgIH0oMCwgMCwgc2VyaWFsaXplZFByb21pc2UpO1xuXHQgICAgICAgICAgICB9LCBfZGVzZXJpYWxpemUuY3Jvc3NfZG9tYWluX2Z1bmN0aW9uID0gZnVuY3Rpb24oc2VyaWFsaXplZEZ1bmN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBvcmlnaW4sIF9yZWY0LCBfcmVmNSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IF9yZWY0LmlkLCBuYW1lID0gX3JlZjQubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY1LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdldERlc2VyaWFsaXplZEZ1bmN0aW9uID0gZnVuY3Rpb24ob3B0cykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG9wdHMgJiYgKG9wdHMgPSB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93LnRvUHJveHlXaW5kb3coc291cmNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aCA9IGxvb2t1cE1ldGhvZCh3aW4sIGlkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aCAmJiBtZXRoLnZhbCAhPT0gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIpIHJldHVybiBtZXRoLnZhbC5hcHBseSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogd2luZG93LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbigpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2FyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmdzID0gW10uc2xpY2UuY2FsbChfYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0cy5maXJlQW5kRm9yZ2V0ID8gc2VuZCh3aW4sIFwicG9zdHJvYm90X21ldGhvZFwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogX2FyZ3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiB0cnVlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBzZW5kKHdpbiwgXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBfYXJnc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6IGZhbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuZGF0YS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19uYW1lX18gPSBuYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX29yaWdpbl9fID0gb3JpZ2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX3NvdXJjZV9fID0gc291cmNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX2lkX18gPSBpZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIub3JpZ2luID0gb3JpZ2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIgPSBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLmZpcmVBbmRGb3JnZXQgPSBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6IHRydWVcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXI7XG5cdCAgICAgICAgICAgICAgICB9KHNvdXJjZSwgb3JpZ2luLCBzZXJpYWxpemVkRnVuY3Rpb24sIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgX2Rlc2VyaWFsaXplLmNyb3NzX2RvbWFpbl93aW5kb3cgPSBmdW5jdGlvbihzZXJpYWxpemVkV2luZG93KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93LmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRXaW5kb3csIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgX2Rlc2VyaWFsaXplKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBTRU5EX01FU1NBR0VfU1RSQVRFR0lFUyA9IHt9O1xuXHQgICAgICAgIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTLnBvc3Ryb2JvdF9wb3N0X21lc3NhZ2UgPSBmdW5jdGlvbih3aW4sIHNlcmlhbGl6ZWRNZXNzYWdlLCBkb21haW4pIHtcblx0ICAgICAgICAgICAgMCA9PT0gZG9tYWluLmluZGV4T2YoXCJmaWxlOlwiKSAmJiAoZG9tYWluID0gXCIqXCIpO1xuXHQgICAgICAgICAgICB3aW4ucG9zdE1lc3NhZ2Uoc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmdW5jdGlvbiBzZW5kX3NlbmRNZXNzYWdlKHdpbiwgZG9tYWluLCBtZXNzYWdlLCBfcmVmMikge1xuXHQgICAgICAgICAgICB2YXIgb24gPSBfcmVmMi5vbiwgc2VuZCA9IF9yZWYyLnNlbmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRvbWFpbkJ1ZmZlciA9IHdpbmRvd1N0b3JlKCkuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmJ1ZmZlciA9IGRvbWFpbkJ1ZmZlci5idWZmZXIgfHwgW107XG5cdCAgICAgICAgICAgICAgICBkb21haW5CdWZmZXIuYnVmZmVyLnB1c2gobWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgICBkb21haW5CdWZmZXIuZmx1c2ggPSBkb21haW5CdWZmZXIuZmx1c2ggfHwgcHJvbWlzZV9aYWxnb1Byb21pc2UuZmx1c2goKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IGlzIGNsb3NlZFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplZE1lc3NhZ2UgPSBzZXJpYWxpemVNZXNzYWdlKHdpbiwgZG9tYWluLCAoKF9yZWYgPSB7fSkuX19wb3N0X3JvYm90XzEwXzBfNDZfXyA9IGRvbWFpbkJ1ZmZlci5idWZmZXIgfHwgW10sIFxuXHQgICAgICAgICAgICAgICAgICAgIF9yZWYpLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkb21haW5CdWZmZXIuYnVmZmVyO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdHJhdGVnaWVzID0gT2JqZWN0LmtleXMoU0VORF9NRVNTQUdFX1NUUkFURUdJRVMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBzdHJhdGVnaWVzLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmF0ZWd5TmFtZSA9IHN0cmF0ZWdpZXNbX2kyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTW3N0cmF0ZWd5TmFtZV0od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSBzdHJhdGVnaWVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiQWxsIHBvc3Qtcm9ib3QgbWVzc2FnaW5nIHN0cmF0ZWdpZXMgZmFpbGVkOlxcblxcblwiICsgZXJyb3JzLm1hcCgoZnVuY3Rpb24oZXJyLCBpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpICsgXCIuIFwiICsgc3RyaW5naWZ5RXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihcIlxcblxcblwiKSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluQnVmZmVyLmZsdXNoLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkb21haW5CdWZmZXIuZmx1c2g7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKS50aGVuKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRSZXNwb25zZUxpc3RlbmVyKGhhc2gpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuZ2V0KGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBkZWxldGVSZXNwb25zZUxpc3RlbmVyKGhhc2gpIHtcblx0ICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKS5kZWwoaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQoaGFzaCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJlcnJvcmVkUmVzcG9uc2VMaXN0ZW5lcnNcIikuaGFzKGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRSZXF1ZXN0TGlzdGVuZXIoX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSwgd2luID0gX3JlZi53aW4sIGRvbWFpbiA9IF9yZWYuZG9tYWluO1xuXHQgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVycyA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdExpc3RlbmVyc1wiKTtcblx0ICAgICAgICAgICAgXCIqXCIgPT09IHdpbiAmJiAod2luID0gbnVsbCk7XG5cdCAgICAgICAgICAgIFwiKlwiID09PSBkb21haW4gJiYgKGRvbWFpbiA9IG51bGwpO1xuXHQgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIk5hbWUgcmVxdWlyZWQgdG8gZ2V0IHJlcXVlc3QgbGlzdGVuZXJcIik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9yZWYzID0gWyB3aW4sIGdldFdpbGRjYXJkKCkgXTsgX2k0IDwgX3JlZjMubGVuZ3RoOyBfaTQrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpblF1YWxpZmllciA9IF9yZWYzW19pNF07XG5cdCAgICAgICAgICAgICAgICBpZiAod2luUXVhbGlmaWVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVMaXN0ZW5lcnMgPSByZXF1ZXN0TGlzdGVuZXJzLmdldCh3aW5RdWFsaWZpZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lTGlzdGVuZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW5MaXN0ZW5lcnMgPSBuYW1lTGlzdGVuZXJzW25hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGRvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnNbZG9tYWluXSkgcmV0dXJuIGRvbWFpbkxpc3RlbmVyc1tkb21haW5dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXykgZm9yICh2YXIgX2k2ID0gMCwgX2RvbWFpbkxpc3RlbmVycyRfX0RPMiA9IGRvbWFpbkxpc3RlbmVycy5fX2RvbWFpbl9yZWdleF9fOyBfaTYgPCBfZG9tYWluTGlzdGVuZXJzJF9fRE8yLmxlbmd0aDsgX2k2KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9kb21haW5MaXN0ZW5lcnMkX19ETzMgPSBfZG9tYWluTGlzdGVuZXJzJF9fRE8yW19pNl0sIGxpc3RlbmVyID0gX2RvbWFpbkxpc3RlbmVycyRfX0RPMy5saXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoRG9tYWluKF9kb21haW5MaXN0ZW5lcnMkX19ETzMucmVnZXgsIGRvbWFpbikpIHJldHVybiBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzW1wiKlwiXSkgcmV0dXJuIGRvbWFpbkxpc3RlbmVyc1tcIipcIl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWUsXG5cdCAgICAgICAgICAgICAgICB3aW46IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB2YXIgbG9nTmFtZSA9IFwicG9zdHJvYm90X21ldGhvZFwiID09PSBtZXNzYWdlLm5hbWUgJiYgbWVzc2FnZS5kYXRhICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIG1lc3NhZ2UuZGF0YS5uYW1lID8gbWVzc2FnZS5kYXRhLm5hbWUgKyBcIigpXCIgOiBtZXNzYWdlLm5hbWU7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNlbmRSZXNwb25zZShhY2ssIGRhdGEsIGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuZmx1c2goKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCAmJiAhaXNXaW5kb3dDbG9zZWQoc291cmNlKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZE1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB1bmlxdWVJRCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4od2luZG93KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IG1lc3NhZ2UuaGFzaCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjazogYWNrLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZW5kIHJlc3BvbnNlIG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuYWxsKFsgcHJvbWlzZV9aYWxnb1Byb21pc2UuZmx1c2goKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5maXJlQW5kRm9yZ2V0ICYmICFpc1dpbmRvd0Nsb3NlZChzb3VyY2UpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB1bmlxdWVJRCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbih3aW5kb3cpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX2Fja1wiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBtZXNzYWdlLmhhc2gsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZVxuXHQgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZW5kIGFjayBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSkpLCBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuaGFuZGxlcih7XG5cdCAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YTogbWVzc2FnZS5kYXRhXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzZW5kUmVzcG9uc2UoXCJzdWNjZXNzXCIsIGRhdGEpO1xuXHQgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKFwiZXJyb3JcIiwgbnVsbCwgZXJyb3IpO1xuXHQgICAgICAgICAgICB9KSkgXSkudGhlbihzcmNfdXRpbF9ub29wKS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZUVycm9yKSByZXR1cm4gb3B0aW9ucy5oYW5kbGVFcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUFjayhzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkge1xuXHQgICAgICAgICAgICBpZiAoIWlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQobWVzc2FnZS5oYXNoKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZSBhY2sgZm9yIG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKG9wdGlvbnMuZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2ggZG9tYWluIFwiICsgb3B0aW9ucy5kb21haW4udG9TdHJpbmcoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gb3B0aW9ucy53aW4pIHRocm93IG5ldyBFcnJvcihcIkFjayBzb3VyY2UgZG9lcyBub3QgbWF0Y2ggcmVnaXN0ZXJlZCB3aW5kb3dcIik7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmFjayA9IHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgaWYgKCFpc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKG1lc3NhZ2UuaGFzaCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0UmVzcG9uc2VMaXN0ZW5lcihtZXNzYWdlLmhhc2gpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgcmVzcG9uc2UgZm9yIG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbihvcHRpb25zLmRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2Ugb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2ggZG9tYWluIFwiICsgKHBhdHRlcm4gPSBvcHRpb25zLmRvbWFpbiwgXG5cdCAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHBhdHRlcm4pID8gXCIoXCIgKyBwYXR0ZXJuLmpvaW4oXCIgfCBcIikgKyBcIilcIiA6IGlzUmVnZXgocGF0dGVybikgPyBcIlJlZ0V4cChcIiArIHBhdHRlcm4udG9TdHJpbmcoKSArIFwiKVwiIDogcGF0dGVybi50b1N0cmluZygpKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGF0dGVybjtcblx0ICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IG9wdGlvbnMud2luKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBzb3VyY2UgZG9lcyBub3QgbWF0Y2ggcmVnaXN0ZXJlZCB3aW5kb3dcIik7XG5cdCAgICAgICAgICAgICAgICBkZWxldGVSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG5cdCAgICAgICAgICAgICAgICBcImVycm9yXCIgPT09IG1lc3NhZ2UuYWNrID8gb3B0aW9ucy5wcm9taXNlLnJlamVjdChtZXNzYWdlLmVycm9yKSA6IFwic3VjY2Vzc1wiID09PSBtZXNzYWdlLmFjayAmJiBvcHRpb25zLnByb21pc2UucmVzb2x2ZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YTogbWVzc2FnZS5kYXRhXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiByZWNlaXZlX3JlY2VpdmVNZXNzYWdlKGV2ZW50LCBfcmVmMikge1xuXHQgICAgICAgICAgICB2YXIgb24gPSBfcmVmMi5vbiwgc2VuZCA9IF9yZWYyLnNlbmQ7XG5cdCAgICAgICAgICAgIHZhciByZWNlaXZlZE1lc3NhZ2VzID0gZ2xvYmFsU3RvcmUoXCJyZWNlaXZlZE1lc3NhZ2VzXCIpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cgfHwgd2luZG93LmNsb3NlZCB8fCAhZXZlbnQuc291cmNlKSByZXR1cm47XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UsIG9yaWdpbiA9IGV2ZW50Lm9yaWdpbjtcblx0ICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gZnVuY3Rpb24obWVzc2FnZSwgc291cmNlLCBvcmlnaW4sIF9yZWYpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWYub24sIHNlbmQgPSBfcmVmLnNlbmQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyc2VkTWVzc2FnZTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyc2VkTWVzc2FnZSA9IGRlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHBhcnNlZE1lc3NhZ2UgJiYgbnVsbCAhPT0gcGFyc2VkTWVzc2FnZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZU1lc3NhZ2VzID0gcGFyc2VkTWVzc2FnZS5fX3Bvc3Rfcm9ib3RfMTBfMF80Nl9fO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlTWVzc2FnZXMpKSByZXR1cm4gcGFyc2VNZXNzYWdlcztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfShldmVudC5kYXRhLCBzb3VyY2UsIG9yaWdpbiwge1xuXHQgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG5cdCAgICAgICAgICAgICAgICBtYXJrV2luZG93S25vd24oc291cmNlKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG1lc3NhZ2VzLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW19pMl07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UuaWQpKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWRNZXNzYWdlcy5zZXQobWVzc2FnZS5pZCwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHNvdXJjZSkgJiYgIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIDAgPT09IG1lc3NhZ2Uub3JpZ2luLmluZGV4T2YoXCJmaWxlOlwiKSAmJiAob3JpZ2luID0gXCJmaWxlOi8vXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zdHJvYm90X21lc3NhZ2VfcmVxdWVzdFwiID09PSBtZXNzYWdlLnR5cGUgPyBoYW5kbGVSZXF1ZXN0KHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXNwb25zZVwiID09PSBtZXNzYWdlLnR5cGUgPyBoYW5kbGVSZXNwb25zZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkgOiBcInBvc3Ryb2JvdF9tZXNzYWdlX2Fja1wiID09PSBtZXNzYWdlLnR5cGUgJiYgaGFuZGxlQWNrKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gb25fb24obmFtZSwgb3B0aW9ucywgaGFuZGxlcikge1xuXHQgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5hbWVcIik7XG5cdCAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkpIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRpb25zO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghaGFuZGxlcikgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaGFuZGxlclwiKTtcblx0ICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZFJlcXVlc3RMaXN0ZW5lcihfcmVmNCwgbGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjQubmFtZSwgd2luQ2FuZGlkYXRlID0gX3JlZjQud2luLCBkb21haW4gPSBfcmVmNC5kb21haW47XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVycyA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdExpc3RlbmVyc1wiKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbmFtZSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIHJlcXVpcmVkIHRvIGFkZCByZXF1ZXN0IGxpc3RlbmVyXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbkNhbmRpZGF0ZSAmJiBcIipcIiAhPT0gd2luQ2FuZGlkYXRlICYmIHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbkNhbmRpZGF0ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVyUHJvbWlzZSA9IHdpbkNhbmRpZGF0ZS5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKGFjdHVhbFdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW46IGFjdHVhbFdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RMaXN0ZW5lclByb21pc2UudGhlbigoZnVuY3Rpb24ocmVxdWVzdExpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RMaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luID0gd2luQ2FuZGlkYXRlO1xuXHQgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkod2luKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnNDb2xsZWN0aW9uID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX3dpbjIgPSB3aW47IF9pOCA8IF93aW4yLmxlbmd0aDsgX2k4KyspIGxpc3RlbmVyc0NvbGxlY3Rpb24ucHVzaChhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luOiBfd2luMltfaThdXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBsaXN0ZW5lcnNDb2xsZWN0aW9uLmxlbmd0aDsgX2kxMCsrKSBsaXN0ZW5lcnNDb2xsZWN0aW9uW19pMTBdLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRvbWFpbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2xpc3RlbmVyc0NvbGxlY3Rpb24gPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTEyID0gMCwgX2RvbWFpbjIgPSBkb21haW47IF9pMTIgPCBfZG9tYWluMi5sZW5ndGg7IF9pMTIrKykgX2xpc3RlbmVyc0NvbGxlY3Rpb24ucHVzaChhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfZG9tYWluMltfaTEyXVxuXHQgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTQgPSAwOyBfaTE0IDwgX2xpc3RlbmVyc0NvbGxlY3Rpb24ubGVuZ3RoOyBfaTE0KyspIF9saXN0ZW5lcnNDb2xsZWN0aW9uW19pMTRdLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0xpc3RlbmVyID0gZ2V0UmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHdpbiAmJiBcIipcIiAhPT0gd2luIHx8ICh3aW4gPSBnZXRXaWxkY2FyZCgpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdHJEb21haW4gPSAoZG9tYWluID0gZG9tYWluIHx8IFwiKlwiKS50b1N0cmluZygpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nTGlzdGVuZXIpIHRocm93IHdpbiAmJiBkb21haW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBvbiBkb21haW4gXCIgKyBkb21haW4udG9TdHJpbmcoKSArIFwiIGZvciBcIiArICh3aW4gPT09IGdldFdpbGRjYXJkKCkgPyBcIndpbGRjYXJkXCIgOiBcInNwZWNpZmllZFwiKSArIFwiIHdpbmRvd1wiKSA6IHdpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIGZvciBcIiArICh3aW4gPT09IGdldFdpbGRjYXJkKCkgPyBcIndpbGRjYXJkXCIgOiBcInNwZWNpZmllZFwiKSArIFwiIHdpbmRvd1wiKSA6IGRvbWFpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIG9uIGRvbWFpbiBcIiArIGRvbWFpbi50b1N0cmluZygpKSA6IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZUxpc3RlbmVycyA9IHJlcXVlc3RMaXN0ZW5lcnMuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVEb21haW5MaXN0ZW5lcnMgPSB1dGlsX2dldE9yU2V0KHdpbk5hbWVMaXN0ZW5lcnMsIG5hbWUsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgdXRpbF9pc1JlZ2V4KGRvbWFpbikgPyAod2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzID0gdXRpbF9nZXRPclNldCh3aW5OYW1lRG9tYWluTGlzdGVuZXJzLCBcIl9fZG9tYWluX3JlZ2V4X19cIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICAgICAgICAgIH0pKSkucHVzaCh3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICByZWdleDogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuXHQgICAgICAgICAgICAgICAgfSkgOiB3aW5OYW1lRG9tYWluTGlzdGVuZXJzW3N0ckRvbWFpbl0gPSBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdpbk5hbWVEb21haW5MaXN0ZW5lcnNbc3RyRG9tYWluXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMuc3BsaWNlKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycy5pbmRleE9mKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyLCAxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMubGVuZ3RoIHx8IGRlbGV0ZSB3aW5OYW1lRG9tYWluTGlzdGVuZXJzLl9fZG9tYWluX3JlZ2V4X187XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMod2luTmFtZURvbWFpbkxpc3RlbmVycykubGVuZ3RoIHx8IGRlbGV0ZSB3aW5OYW1lTGlzdGVuZXJzW25hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4gJiYgIU9iamVjdC5rZXlzKHdpbk5hbWVMaXN0ZW5lcnMpLmxlbmd0aCAmJiByZXF1ZXN0TGlzdGVuZXJzLmRlbCh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgIHdpbjogb3B0aW9ucy53aW5kb3csXG5cdCAgICAgICAgICAgICAgICBkb21haW46IG9wdGlvbnMuZG9tYWluIHx8IFwiKlwiXG5cdCAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIgfHwgb3B0aW9ucy5oYW5kbGVyLFxuXHQgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3I6IG9wdGlvbnMuZXJyb3JIYW5kbGVyIHx8IGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RMaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gb25fb25jZShuYW1lLCBvcHRpb25zLCBoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkpIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRpb25zO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG5cdCAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGxpc3RlbmVyID0gb25fb24obmFtZSwgb3B0aW9ucywgKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShldmVudCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikgcmV0dXJuIGhhbmRsZXIoZXZlbnQpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHByb21pc2UuY2FuY2VsID0gbGlzdGVuZXIuY2FuY2VsO1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNlbmRfc2VuZCA9IGZ1bmN0aW9uIHNlbmQod2luT3JQcm94eVdpbiwgbmFtZSwgZGF0YSwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgZG9tYWluTWF0Y2hlciA9IChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkuZG9tYWluIHx8IFwiKlwiO1xuXHQgICAgICAgICAgICB2YXIgcmVzcG9uc2VUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IC0xO1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDVlMztcblx0ICAgICAgICAgICAgdmFyIGZpcmVBbmRGb3JnZXQgPSBvcHRpb25zLmZpcmVBbmRGb3JnZXQgfHwgZmFsc2U7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyh3aW5PclByb3h5V2luLCB7XG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgIH0pLmF3YWl0V2luZG93KCkudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24obmFtZSwgd2luLCBkb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBuYW1lXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZG9tYWluICYmICFBcnJheS5pc0FycmF5KGRvbWFpbikgJiYgIXV0aWxfaXNSZWdleChkb21haW4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBzZW5kIFwiICsgbmFtZSArIFwiLiBFeHBlY3RlZCBkb21haW4gXCIgKyBKU09OLnN0cmluZ2lmeShkb21haW4pICsgXCIgdG8gYmUgYSBzdHJpbmcsIGFycmF5LCBvciByZWdleFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgc2VuZCBcIiArIG5hbWUgKyBcIi4gVGFyZ2V0IHdpbmRvdyBpcyBjbG9zZWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfShuYW1lLCB3aW4sIGRvbWFpbk1hdGNoZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbihwYXJlbnQsIGNoaWxkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3R1YWxQYXJlbnQgPSBnZXRBbmNlc3RvcihjaGlsZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3R1YWxQYXJlbnQpIHJldHVybiBhY3R1YWxQYXJlbnQgPT09IHBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4udG9wKSByZXR1cm4gd2luLnRvcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRQYXJlbnQod2luKSA9PT0gd2luKSByZXR1cm4gd2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbmNlc3RvclBhcmVudCh3aW5kb3csIHdpbikgJiYgd2luZG93LnRvcCkgcmV0dXJuIHdpbmRvdy50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yUGFyZW50KHdpbiwgd2luZG93KSAmJiB3aW5kb3cudG9wKSByZXR1cm4gd2luZG93LnRvcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNyA9IDAsIF9nZXRBbGxDaGlsZEZyYW1lczQgPSBmdW5jdGlvbiBnZXRBbGxDaGlsZEZyYW1lcyh3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMCwgX2dldEZyYW1lczIgPSBnZXRGcmFtZXMod2luKTsgX2kzIDwgX2dldEZyYW1lczIubGVuZ3RoOyBfaTMrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfZ2V0RnJhbWVzMltfaTNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNSA9IDAsIF9nZXRBbGxDaGlsZEZyYW1lczIgPSBnZXRBbGxDaGlsZEZyYW1lcyhmcmFtZSk7IF9pNSA8IF9nZXRBbGxDaGlsZEZyYW1lczIubGVuZ3RoOyBfaTUrKykgcmVzdWx0LnB1c2goX2dldEFsbENoaWxkRnJhbWVzMltfaTVdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0od2luKTsgX2k3IDwgX2dldEFsbENoaWxkRnJhbWVzNC5sZW5ndGg7IF9pNysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2dldEFsbENoaWxkRnJhbWVzNFtfaTddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZS50b3ApIHJldHVybiBmcmFtZS50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRQYXJlbnQoZnJhbWUpID09PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KGNoaWxkKSA9PT0gY2hpbGQpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxNSA9IDAsIF9nZXRGcmFtZXM4ID0gZ2V0RnJhbWVzKHBhcmVudCk7IF9pMTUgPCBfZ2V0RnJhbWVzOC5sZW5ndGg7IF9pMTUrKykgaWYgKF9nZXRGcmFtZXM4W19pMTVdID09PSBjaGlsZCkgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9KHdpbmRvdywgd2luKSkgcmV0dXJuIGZ1bmN0aW9uKHdpbiwgdGltZW91dCwgbmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHRpbWVvdXQgJiYgKHRpbWVvdXQgPSA1ZTMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG5hbWUgJiYgKG5hbWUgPSBcIldpbmRvd1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcImhlbGxvUHJvbWlzZXNcIikuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAtMSAhPT0gdGltZW91dCAmJiAocHJvbWlzZSA9IHByb21pc2UudGltZW91dCh0aW1lb3V0LCBuZXcgRXJyb3IobmFtZSArIFwiIGRpZCBub3QgbG9hZCBhZnRlciBcIiArIHRpbWVvdXQgKyBcIm1zXCIpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0od2luLCBjaGlsZFRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKF90ZW1wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHdpbiwgdGFyZ2V0RG9tYWluLCBhY3R1YWxEb21haW4sIF9yZWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmLnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHRhcmdldERvbWFpbiA/IHRhcmdldERvbWFpbiA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbERvbWFpbiB8fCBzYXlIZWxsbyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMi5kb21haW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKG5vcm1hbGl6ZWREb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKHRhcmdldERvbWFpbiwgdGFyZ2V0RG9tYWluKSkgdGhyb3cgbmV3IEVycm9yKFwiRG9tYWluIFwiICsgc3RyaW5naWZ5KHRhcmdldERvbWFpbikgKyBcIiBkb2VzIG5vdCBtYXRjaCBcIiArIHN0cmluZ2lmeSh0YXJnZXREb21haW4pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZERvbWFpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0od2luLCBkb21haW5NYXRjaGVyLCAodm9pZCAwID09PSBfdGVtcCA/IHt9IDogX3RlbXApLmRvbWFpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24odGFyZ2V0RG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHRhcmdldERvbWFpbjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbG9nTmFtZSA9IFwicG9zdHJvYm90X21ldGhvZFwiID09PSBuYW1lICYmIGRhdGEgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZGF0YS5uYW1lID8gZGF0YS5uYW1lICsgXCIoKVwiIDogbmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IG5hbWUgKyBcIl9cIiArIHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJlQW5kRm9yZ2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZUxpc3RlbmVyID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihoYXNoLCBsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKS5zZXQoaGFzaCwgbGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KGhhc2gsIHJlc3BvbnNlTGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxUHJvbWlzZXMgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RQcm9taXNlc1wiKS5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXFQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhdGNoKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihoYXNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJlcnJvcmVkUmVzcG9uc2VMaXN0ZW5lcnNcIikuc2V0KGhhc2gsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShoYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIoaGFzaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsQWNrVGltZW91dCA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwia25vd25XaW5kb3dzXCIpLmdldCh3aW4sIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW4pID8gMWU0IDogMmUzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxSZXNUaW1lb3V0ID0gcmVzcG9uc2VUaW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWNrVGltZW91dCA9IHRvdGFsQWNrVGltZW91dDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc1RpbWVvdXQgPSB0b3RhbFJlc1RpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGZ1bmN0aW9uKG1ldGhvZCwgdGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24gbG9vcCgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSByZXR1cm4gcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV2luZG93IGNsb3NlZCBmb3IgXCIgKyBuYW1lICsgXCIgYmVmb3JlIFwiICsgKHJlc3BvbnNlTGlzdGVuZXIuYWNrID8gXCJyZXNwb25zZVwiIDogXCJhY2tcIikpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUxpc3RlbmVyLmNhbmNlbGxlZCkgcmV0dXJuIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlJlc3BvbnNlIGxpc3RlbmVyIHdhcyBjYW5jZWxsZWQgZm9yIFwiICsgbmFtZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNrVGltZW91dCA9IE1hdGgubWF4KGFja1RpbWVvdXQgLSA1MDAsIDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgIT09IHJlc1RpbWVvdXQgJiYgKHJlc1RpbWVvdXQgPSBNYXRoLm1heChyZXNUaW1lb3V0IC0gNTAwLCAwKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUxpc3RlbmVyLmFjayB8fCAwICE9PSBhY2tUaW1lb3V0ID8gMCA9PT0gcmVzVGltZW91dCAmJiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmb3IgcG9zdE1lc3NhZ2UgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiIGluIFwiICsgdG90YWxSZXNUaW1lb3V0ICsgXCJtc1wiKSkgOiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBhY2sgZm9yIHBvc3RNZXNzYWdlIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIiBpbiBcIiArIHRvdGFsQWNrVGltZW91dCArIFwibXNcIikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgNTAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5maW5hbGx5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxUHJvbWlzZXMuc3BsaWNlKHJlcVByb21pc2VzLmluZGV4T2YocHJvbWlzZSwgMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHdpbiwgZG9tYWluLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB1bmlxdWVJRCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbih3aW5kb3cpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogZmlyZUFuZEZvcmdldFxuXHQgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJlQW5kRm9yZ2V0ID8gcHJvbWlzZS5yZXNvbHZlKCkgOiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgcmVxdWVzdCBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwX3NlcmlhbGl6ZU1lc3NhZ2UoZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaiwge1xuXHQgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBjcmVhdGVQcm94eVdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3dfUHJveHlXaW5kb3coe1xuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kLFxuXHQgICAgICAgICAgICAgICAgd2luOiB3aW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwX3RvUHJveHlXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0dXAoKSB7XG5cdCAgICAgICAgICAgIGlmICghZ2xvYmFsX2dldEdsb2JhbCgpLmluaXRpYWxpemVkKSB7XG5cdCAgICAgICAgICAgICAgICBnbG9iYWxfZ2V0R2xvYmFsKCkuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgb24gPSAoX3JlZjMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICAgICAgfSkub24sIHNlbmQgPSBfcmVmMy5zZW5kLCAoZ2xvYmFsID0gZ2xvYmFsX2dldEdsb2JhbCgpKS5yZWNlaXZlTWVzc2FnZSA9IGdsb2JhbC5yZWNlaXZlTWVzc2FnZSB8fCBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAhZnVuY3Rpb24oX3JlZjUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmNS5vbiwgc2VuZCA9IF9yZWY1LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoKS5nZXRPclNldChcInBvc3RNZXNzYWdlTGlzdGVuZXJcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBldmVudCwgaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW5kb3csIDAsIChmdW5jdGlvbihldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGV2ZW50LCBfcmVmNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWY0Lm9uLCBzZW5kID0gX3JlZjQuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50LnNvdXJjZUVsZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBldmVudC5vcmlnaW4gfHwgZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50Lm9yaWdpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm51bGxcIiA9PT0gb3JpZ2luICYmIChvcmlnaW4gPSBcImZpbGU6Ly9cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luKSB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0IG1lc3NhZ2UgZGlkIG5vdCBoYXZlIG9yaWdpbiBkb21haW5cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlX3JlY2VpdmVNZXNzYWdlKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShldmVudCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWY4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZjgub24sIHNlbmQgPSBfcmVmOC5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwiYnVpbHRpbkxpc3RlbmVyc1wiKS5nZXRPclNldChcImhlbGxvTGlzdGVuZXJcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBvbihcInBvc3Ryb2JvdF9oZWxsb1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIChmdW5jdGlvbihfcmVmMykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUhlbGxvUHJvbWlzZShfcmVmMy5zb3VyY2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IF9yZWYzLm9yaWdpblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSUQ6IGdldEluc3RhbmNlSUQoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0QW5jZXN0b3IoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ICYmIHNheUhlbGxvKHBhcmVudCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7fSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSh7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9yZWYzLCBvbiwgc2VuZCwgZ2xvYmFsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VMaXN0ZW5lcnMgPSBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMiA9IHJlc3BvbnNlTGlzdGVuZXJzLmtleXMoKTsgX2kyIDwgX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMi5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBfcmVzcG9uc2VMaXN0ZW5lcnMka2UyW19pMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gcmVzcG9uc2VMaXN0ZW5lcnMuZ2V0KGhhc2gpO1xuXHQgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyICYmIChsaXN0ZW5lci5jYW5jZWxsZWQgPSB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXNwb25zZUxpc3RlbmVycy5kZWwoaGFzaCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgKGxpc3RlbmVyID0gZ2xvYmFsU3RvcmUoKS5nZXQoXCJwb3N0TWVzc2FnZUxpc3RlbmVyXCIpKSAmJiBsaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgdmFyIGxpc3RlbmVyO1xuXHQgICAgICAgICAgICBkZWxldGUgd2luZG93Ll9fcG9zdF9yb2JvdF8xMF8wXzQ2X187XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzcmNfdHlwZXNfVFlQRVNfMCA9IHRydWU7XG5cdCAgICAgICAgZnVuY3Rpb24gY2xlYW5VcFdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3JlcXVlc3RQcm9taXNlcyRnZXQyID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0UHJvbWlzZXNcIikuZ2V0KHdpbiwgW10pOyBfaTIgPCBfcmVxdWVzdFByb21pc2VzJGdldDIubGVuZ3RoOyBfaTIrKykgX3JlcXVlc3RQcm9taXNlcyRnZXQyW19pMl0ucmVqZWN0KG5ldyBFcnJvcihcIldpbmRvdyBcIiArIChpc1dpbmRvd0Nsb3NlZCh3aW4pID8gXCJjbG9zZWRcIiA6IFwiY2xlYW5lZCB1cFwiKSArIFwiIGJlZm9yZSByZXNwb25zZVwiKSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNldHVwKCk7XG5cdCAgICB9IF0pO1xuXHR9KSk7IFxufSAocG9zdFJvYm90KSk7XG5cbnZhciBwb3N0Um9ib3RFeHBvcnRzJDEgPSBwb3N0Um9ib3QuZXhwb3J0cztcblxuLyogQGZsb3cgKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0Ly8gJEZsb3dGaXhNZVxuXHRtb2R1bGUuZXhwb3J0cyA9IHBvc3RSb2JvdEV4cG9ydHMkMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tY29tbW9uanNcblxuXHQvLyAkRmxvd0ZpeE1lXG5cdG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0czsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tY29tbW9uanMgXG59IChwb3N0Um9ib3QkMSkpO1xuXG52YXIgcG9zdFJvYm90RXhwb3J0cyA9IHBvc3RSb2JvdCQxLmV4cG9ydHM7XG52YXIgaW5kZXggPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocG9zdFJvYm90RXhwb3J0cyk7XG5cbnZhciBpbmRleCQxID0gLyojX19QVVJFX18qL19tZXJnZU5hbWVzcGFjZXMoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGRlZmF1bHQ6IGluZGV4XG59LCBbcG9zdFJvYm90RXhwb3J0c10pO1xuXG5leHBvcnQgeyBpbmRleCQxIGFzIGkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/family@0.1.6_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.43.5_bufferutil@4.1.0_t_6a2b9601286a0c7e5bca7efaba4efca1/node_modules/family/lib/index-Cs-onntv.js\n"));

/***/ })

}]);